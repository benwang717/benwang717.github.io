<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>遇到的新知识点罗列</title>
      <link href="/2023/08/04/%E9%81%87%E5%88%B0%E7%9A%84%E6%96%B0%E7%9F%A5%E8%AF%86%E7%82%B9%E7%BD%97%E5%88%97/"/>
      <url>/2023/08/04/%E9%81%87%E5%88%B0%E7%9A%84%E6%96%B0%E7%9F%A5%E8%AF%86%E7%82%B9%E7%BD%97%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>在这里我会把发现的新的但并不是多熟悉的知识点罗列一下, 并且简单的描述一遍, 目的是有序的这些知识点练习掌握并梳理归纳下来. </p><hr><h2 id="知识点罗列-计划中准备梳理归纳的知识点"><a href="#知识点罗列-计划中准备梳理归纳的知识点" class="headerlink" title="知识点罗列&amp;计划中准备梳理归纳的知识点:"></a>知识点罗列&amp;计划中准备梳理归纳的知识点:</h2><ol><li><p>使用qchart组件写一个demo, 建立对它的基本认识</p></li><li><p>通过第四点, 对chartzoom进行深入的理解</p></li><li><p>使用 QCustomPlot 了解它的基本功能, 做到想用的时候会怎么用</p></li><li><p>窗口切换的相关需要注意的问题</p></li><li><p>(.pri)文件及其已有文件的移植问题</p></li><li><p>绘制环形进度条的几种方式</p></li><li><p>模糊动画函数调用QGraphicsBlurEffect&amp;QPropertyAnimation</p></li></ol><p>这个文档完成一条去掉一条, 基本上都会生成相关文档并上传到博客里, 只能说一起加油吧家人们 !</p><p>一些链接:</p><p>测试相关:<a href="https://mp.weixin.qq.com/s/jUO2D5EokbNgZ3Yf0Nm13Q">https://mp.weixin.qq.com/s/jUO2D5EokbNgZ3Yf0Nm13Q</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>父子组件背景问题</title>
      <link href="/2023/07/16/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E8%83%8C%E6%99%AF%E9%97%AE%E9%A2%98/"/>
      <url>/2023/07/16/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E8%83%8C%E6%99%AF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>通常情况下, 在项目中的某一个ui界面我们需要使用美工做的图为背景图,像这样:</p><p><img src="/../images/image-20230810114619308.png" alt="image-20230810114619308"></p><p>此时我们会遇到一些问题, 假设我们需要添加一个QLineEdit组件, 像往常一样拖拽一个QLineEdit组件到我们已经设定了背景图的窗口中, 可以看到效果是这样的. </p><p><img src="/../images/image-20230810114900300.png" alt="image-20230810114900300"></p><p>首先, 我们的QLineEdit组件是设置有样式表的, 如下图</p><p><img src="/../images/image-20230810115121271.png" alt="image-20230810115121271"></p><p>但是为什么在拖拽到组件中我们的样式却消失了?</p><p>其实并不是, 当我们一个子组件拖拽到一个父组件的时候, 这个子组件会继承这个父组件的一些基本的样式信息, 这些基本样式信息中就含有背景图, 也就是说, 这个子组件继承了父组件的背景图.</p><p>所以, 为了避免这种情况影响到我们的需求, 我们再设定组件信息的时候需要初始化子组件的背景图路径, 设一个空路径, 如下图:</p><p><img src="/../images/image-20230810115518015.png" alt="image-20230810115518015"></p><p>注意, url() 中不要填写任何信息, 然后我们再次拖拽到父组件中查看效果, 如下图:</p><p><img src="/../images/image-20230810115624768.png" alt="image-20230810115624768"></p><p>可以看到我们再子组件设定的样式信息保留了下来</p>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> qss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存分区问题</title>
      <link href="/2023/07/04/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E9%97%AE%E9%A2%98/"/>
      <url>/2023/07/04/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>本篇介绍内存分区的相关问题, 网络上相关文章已经有很多了, 这里我会用自己理解认识的方式去描述.</p><p>首先如下图: 对初学者而言, 上来就撂给你一堆分区的概念的时候脑瓜子可能是嗡嗡的, 给人的感觉就是我是谁我在哪. 我认为要真正理解各个分区的概念, 需要在项目中具体使用到产生疑惑的时候, 再看对应的概念. 或许就能豁然开朗.</p><p><img src="/../images/20210319215715539.png"></p><h2 id="1-栈区"><a href="#1-栈区" class="headerlink" title="1. 栈区"></a>1. 栈区</h2><p>栈区由编译器自动分配释放，由操作系统自动管理，无须手动管理。一般可以理解为某一个函数中声明的变量, 并在函数中完成了它的生命周期, 其随着函数的的结束而被释放.<br>栈区按内存地址由高到低方向生长，其最大大小由编译时确定，速度快，但自由性差，最大空间不大。<br>栈区是先进后出原则，即先进去的被堵在屋里的最里面，后进去的在门口，释放的时候门口的先出去。<br>存放内容<br>临时创建的局部变量和const定义的局部变量存放在栈区。<br>函数调用和返回时，其入口参数和返回值存放在栈区。</p><h2 id="2-堆区"><a href="#2-堆区" class="headerlink" title="2. 堆区"></a>2. 堆区</h2><p>堆区由程序员分配内存和释放, 开发者手动开辟手动释放, 无释放在程序结束后自动释放.<br>堆区按内存地址由低到高方向生长，其大小由系统内存&#x2F;虚拟内存上限决定，速度较慢，但自由性大，可用空间大。<br>调用函数<br>用malloc等函数实现动态分布内存。c++中使用new在堆区开辟空间</p><p>void <em>malloc(size_t);<br>参数size_t是分配的字节大小。<br>返回值是一个void</em>型的指针，该指针指向分配空间的首地址。<br>（void *型指针可以任意转换为其他类型的指针）</p><p>用free函数进行内存释放，否则会造成内存泄漏。</p><p>void free(void * &#x2F;<em>ptr</em>&#x2F;);<br>参数是开辟的内存的首地址。</p><h2 id="3-全局-静态-区"><a href="#3-全局-静态-区" class="headerlink" title="3. 全局(静态)区"></a>3. 全局(静态)区</h2><p>通常是用于那些在编译期间就能确定存储大小的变量的存储区，但它用于的是在整个程序运行期间都可见的全局变量和静态变量。<br>全局区有 .bss段 和 .data段组成，可读可写。</p><h3 id="bss段"><a href="#bss段" class="headerlink" title=".bss段"></a>.bss段</h3><p>未初始化的全局变量和未初始化的静态变量存放在.bss段。<br>初始化为0的全局变量和初始化为0的静态变量存放在.bss段。<br>.bss段不占用可执行文件空间，其内容由操作系统初始化。</p><h3 id="data段"><a href="#data段" class="headerlink" title=".data段"></a>.data段</h3><p>已初始化的全局变量存放在.data段。<br>已初始化的静态变量存放在.data段。<br>.data段占用可执行文件空间，其内容有程序初始化。</p><h3 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点:"></a>需要注意的点:</h3><ol><li>在C++中, 静态全局变量独立于实例化对象之外, 一旦定义声明了静态全局的实例化对象, 在程序运行的整个周期, 这个变量会一直存在, 无法通过实例化的类的对象中对应的变量中对其进行修改, 因为通常在C++中我们声明一个类的对象, 并在堆区开辟可空间, 那么该类的对象中的相关成员都会在堆区中分配位置, 这个时候我们再对成员中的静态全局变量赋值, 相当于只赋值在了堆区的对象中, 而我们初始化的静态全局变量的值并没有发生任何改变. </li><li>在使用静态全局区的时候需要慎重, 非必要尽量要少用. 静态全局变量会增加程序负载, 挂载的静态全局变量越多程序负载越大效率越低, 这是第一点; 另外就是声明过多的静态全局变量会增加项目的复杂度, 不利于程序后期的开发和维护.</li></ol><h2 id="4-常量区"><a href="#4-常量区" class="headerlink" title="4. 常量区"></a>4. 常量区</h2><p>字符串、数字等常量存放在常量区。<br>const修饰的全局变量存放在常量区。<br>程序运行期间，常量区的内容不可以被修改。</p><h2 id="5-代码区"><a href="#5-代码区" class="headerlink" title="5. 代码区"></a>5. 代码区</h2><p>程序执行代码存放在代码区，其值不能修改（若修改则会出现错误）。<br>字符串常量和define定义的常量也有可能存放在代码区。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>json接口解析</title>
      <link href="/2023/06/09/json%E6%8E%A5%E5%8F%A3%E8%A7%A3%E6%9E%90/"/>
      <url>/2023/06/09/json%E6%8E%A5%E5%8F%A3%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>​常用的json接口大概有两种类型, 一个是简单的可以直接使用jsonArray解析的接口,  说人话就是, 接口返回的信息简单重复且单一, 另一个是使用jsonArray配合jsonObject使用的接口类型, 说人话就是, 接口返回的信息类型较为复杂, 可能包含多组数据信息. 下面会对如何解析这两种类型的返回接口举出实例进行讲解. </p><h2 id="json接口解析"><a href="#json接口解析" class="headerlink" title="json接口解析"></a>json接口解析</h2><p>这个是第一种:</p><p><img src="/../images/image-20230809141706160.png" alt="image-20230809141706160"></p><p>这是第二种:</p><p><img src="/../images/image-20230809142038049.png" alt="image-20230809142038049"></p><p>第一种解析逻辑比较简单, 暂时我就不写了 (以后有时间看心情补上(*￣︶￣) ), 主要是第二种解析方式, 第二种解析方式如果搞明白, 第一种其实也不必多说了.</p><h3 id="第一步-找到合适的接口"><a href="#第一步-找到合适的接口" class="headerlink" title="第一步: 找到合适的接口"></a>第一步: 找到合适的接口</h3><p>首先是找个接口, 这里我以百度热搜的接口为例</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该接口截止到我写的时候还能用, 如果不能用请自己找个接口练习</span></span><br><span class="line">https:<span class="comment">//top.baidu.com/api/board?platform=wise&amp;tab=realtime</span></span><br></pre></td></tr></table></figure><p>使用postman返回的格式如下:</p><p><img src="/../images/image-20230809143116595.png" alt="image-20230809143116595"></p><h3 id="第二步-明确要捕获的接口信息"><a href="#第二步-明确要捕获的接口信息" class="headerlink" title="第二步: 明确要捕获的接口信息"></a>第二步: 明确要捕获的接口信息</h3><p>我们以百度热搜榜为例, 要通过接口, 依次获取热搜标题, 并把这些标题展示在我们自定义的组件上</p><p><img src="/../images/image-20230809143539066.png" alt="image-20230809143539066"></p><p>首先是分析接口格式:</p><p><img src="/../images/image-20230809150712703.png" alt="image-20230809150712703"></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"># 这里是接口的返回值<span class="punctuation">,</span> 由于返回的内容较多<span class="punctuation">,</span>这里就不再全部展示</span><br><span class="line"># 以我们需要的信息具体分析</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;success&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;cards&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;component&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hotList&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;appUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;hotChange&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;hotScore&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;hotTag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;hotTagImg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;img&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> *<span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;indexUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;女儿不需要报销妈妈感慨自己没用了&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;rawUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;show&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;word&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;appUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;hotChange&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;hotScore&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;hotTag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;hotTagImg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;img&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> *<span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;indexUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;双胞胎暴雨中降生被起名定海神针&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;rawUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;show&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;more&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;moreAppUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;moreUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;topContent&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;appUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;hotChange&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;hotScore&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;hotTag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;img&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> *<span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;indexUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;rawUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;show&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;word&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;typeName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;updateTime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;curBoardName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;logid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;platform&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tag&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;api response ok&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>通过接口可以看到,我们最终需要的信息是 query 对应的值, 现在分析这个接口的结构, 首先不同于简单接口返回都是单一重复的array类型, 该接口上来就返回有几个不同的键:”success”&amp;”data”&amp;”error”, 然后逐下分层, 很明显我们需要的 “query” 在 “data” 这个对象里.</p><p>下面两个点需要注意的:</p><p>凡是冒号后跟 { } 的(例如”demo” :{ }) , 都是 QJsonObject类型;</p><p>凡是冒号后跟 [ ] 的(例如”demo” :[ ]) , 都是QJsonArray类型.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从根对象中获取&quot;data&quot;键对应的值</span></span><br><span class="line">QJsonObject dataObj = jsonObj[<span class="string">&quot;data&quot;</span>].<span class="built_in">toObject</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从&quot;data&quot;对象中获取&quot;cards&quot;键对应的值</span></span><br><span class="line">QJsonArray cardsArray = dataObj[<span class="string">&quot;cards&quot;</span>].<span class="built_in">toArray</span>();</span><br><span class="line"></span><br><span class="line">QStringList list;</span><br><span class="line"><span class="comment">// 由于&quot;cards&quot;键对应的值是一个数组，我们遍历这个数组</span></span><br><span class="line">foreach (<span class="type">const</span> QJsonValue &amp;cardVal, cardsArray) &#123;</span><br><span class="line">    <span class="comment">// 获取数组中的每个元素，这里假设每个元素都是一个对象</span></span><br><span class="line">    QJsonObject cardObj = cardVal.<span class="built_in">toObject</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在每个元素中查找&quot;content&quot;键对应的值</span></span><br><span class="line">    QJsonArray contentArray = cardObj[<span class="string">&quot;content&quot;</span>].<span class="built_in">toArray</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历&quot;content&quot;数组</span></span><br><span class="line">    foreach (<span class="type">const</span> QJsonValue &amp;contentVal, contentArray) &#123;</span><br><span class="line">        <span class="comment">// 获取数组中的每个元素</span></span><br><span class="line">        QJsonObject contentObj = contentVal.<span class="built_in">toObject</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取&quot;query&quot;键对应的值</span></span><br><span class="line">        QString query = contentObj[<span class="string">&quot;query&quot;</span>].<span class="built_in">toString</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这里可以使用获取到的&quot;appUrl&quot;值进行后续操作</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//qDebug() &lt;&lt;count&lt;&lt; query;//测试输出数据</span></span><br><span class="line">        query = QString::<span class="built_in">number</span>(count) + <span class="string">&quot;. &quot;</span> + query;</span><br><span class="line">        list.<span class="built_in">append</span>(query);<span class="comment">//保存对应信息</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>核心逻辑就是这些了, 其实逻辑比较简答, 就是涉及到具体json接口的时候如果比较复杂可能会比较绕脑子, 多测试一下就可以了. 下面是我的演示输出.</p><p><img src="/../images/image-20230809151041417.png" alt="image-20230809151041417"></p><p>懒得传了, 后续再上传仓库吧, 需要 demo 的可以联系我(*￣︶￣)</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Qt </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件打包</title>
      <link href="/2023/05/12/%E8%BD%AF%E4%BB%B6%E6%89%93%E5%8C%85%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2023/05/12/%E8%BD%AF%E4%BB%B6%E6%89%93%E5%8C%85%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<hr><p>简述: 打包方式千千万, 有一个自己用的熟悉且好用的打包方式, 能适配你很多打包的需求. 这里还需要培养自己规避异常的意识. </p><h3 id="程序打包之-SetupFactory"><a href="#程序打包之-SetupFactory" class="headerlink" title="程序打包之:  SetupFactory"></a>程序打包之:  SetupFactory<img src="/../images/image-20230803150722311.png" alt="image-20230803150722311"></h3><p>我目前主要使用这个软件打包, 下面我会从零开始打包一个软件, 这里我会把需要考虑到的问题和需要做的配置描述清楚. </p><p><img src="/../images/image-20230803150957503.png" alt="image-20230803150957503"></p><p>上图是软件主界面, 在我们打包软件之前, 首先需要拿到程序的可执行文件, 这里我们以Qt项目中构建的可执行文件(.exe)为例进行打包. </p><h3 id="一-找到可执行文件"><a href="#一-找到可执行文件" class="headerlink" title="一.  找到可执行文件"></a>一.  找到可执行文件</h3><p>​qt项目中, 构建目录中依照我们的构建方式 (release或者debug) ,可以在对应的文件夹中找到可执行文件, 如下图</p><p><img src="/../images/image-20230803151917456.png" alt="image-20230803151917456"></p><p>提示一下, 通常公司中的项目打包以release中的可执行文件为准, 不使用debug打包, 原因不再赘述</p><h3 id="二-配置必要的源文件"><a href="#二-配置必要的源文件" class="headerlink" title="二. 配置必要的源文件"></a>二. 配置必要的源文件</h3><p>在配置文件之前, 首先在自定义路径创建一个文件夹, 命名自定义 (我习惯使用”项目名+packet”) . 然后将我们找到的可执行文件(.exe) 拷贝到文件夹中.</p><p><img src="/../images/image-20230803152425850.png" alt="image-20230803152425850"></p><p>接下来是一些需要着重在意的步骤:</p><ol><li>首先项目是在qt中构建的, 所以我们应该配置必要qt核心库</li><li>在一些项目中, 可能存在一些外部配置文件, 这些外部文件可能是我们自定义的组件图片&#x2F; 必要的自定义组件样式表&#x2F; 必要的外部动态库&#x2F; 必要的外部数据库&#x2F; …  这些文件也需要根据其相对路径位置, 放到我们的同级目录下</li><li>对于开发者而言, 大多数情况下, 如果我们把打包前的准备工作做完, 程序在该路径下打开就可以”正常”运行了, 但这种”正常”并不一定是真的正常, 因为开发者电脑所处的环境已经配置好了所有必要的环境变量, 因此在配置好相关文件之后, 第一时间不需要打包程序, 把packet文件夹压缩一下, 拿到一个没有配置的任何环境变量的电脑里解压测试一下软件是否可以正常打开, 如果软件成功打开 ( 可以正常打开但是涉及到有外部样式组件的时候, 还是需要打开检查一下是否样式文件被配置到程序中了, 如果没有样式那就是位置放置有误 ) , 那么我们的打包前的准备就无误了, 否则还需要调整.</li></ol><p>接下来依次操作:</p><p>首先, 配置qt中必要的核心库, 这是qt项目中打包的必要步骤, 我们打开打包文件夹, 按住shift键右击鼠标, 点击 <u>在此处打开powershell窗口</u></p><p><img src="/../images/image-20230803154800969.png" alt="image-20230803154800969"></p><p>这里我们会自动定位当前位置所在路径:</p><p><img src="/../images/image-20230803154947859.png" alt="image-20230803154947859"></p><p>然后输入: “windeployqt  BMS_FirmwareUpgradePlatformV2.exe” </p><p><img src="/../images/image-20230803155310488.png" alt="image-20230803155310488"></p><p>这里要注意windeployqt 后是可执行文件的全称, 包括后缀.exe , 接下来点击回车</p><p><img src="/../images/image-20230803155435917.png" alt="image-20230803155435917"></p><p>这里就开始部署相关文件, 可以看到文件夹中添加了必要的配置文件</p><p><img src="/../images/image-20230803155541208.png" alt="image-20230803155541208"></p><p>以上我们完成了配置文件的第一个步骤, 然后我们要回到项目本身, 检查项目中是否存在外部配置文件, 把这些文件按照相对路基放到打包目录中去</p><p><img src="/../images/image-20230803160225658.png" alt="image-20230803160225658"></p><p>完成这一步确认没有遗漏之后, 我们需要把这个文件夹压缩一下, 拷贝到另一台没有配置任何环境的电脑中,  解压并打开检查是否能够正常打开 (可以正常打开但是涉及到有外部样式组件的时候, 还是需要打开检查一下是否样式文件被配置到程序中了, 如果没有样式那就是位置放置有误) , 如果可以说明配置完成, 否则需要补充配置文件. </p><p><img src="/../images/image-20230803160711288.png" alt="image-20230803160711288"></p><p>这里不再演示, 我们默认配置成功, 现在回到打包目录</p><p><img src="/../images/image-20230803160821432.png" alt="image-20230803160821432"></p><p>以上, 我们就完成了打包前必要文件的配置. 先别着急, 这里对于上述步骤中的 windeployqt 还需要多啰嗦一下,  你可以简单的这样理解, 不同的qt版本, 进行 windeployqt *.exe 产生的配置文件大小是不一样的, 这是我发现的, 我不确定版本是否向下兼容, 这个差异对项目的可执行是有影响的! 所以如果你不是某个项目的初次开发者, 在涉及到项目打包的时候, 一定要用前人的 windeployqt 配置产生的文件才能确保程序的运行 ( 别的开发环境也一样道理 ).</p><h3 id="三-开始打包-打包软件的基本信息配置"><a href="#三-开始打包-打包软件的基本信息配置" class="headerlink" title="三.  开始打包 &#x2F; 打包软件的基本信息配置"></a>三.  开始打包 &#x2F; 打包软件的基本信息配置</h3><p>回到开头, 我们软件打包的界面</p><p><img src="/../images/image-20230803161823976.png" alt="image-20230803161823976"></p><p>首先我们需要新建一个项目, 是的, 新建打包的项目, 现在不要迷糊</p><p><img src="/../images/image-20230803162234486.png" alt="image-20230803162234486"></p><p><img src="/../images/image-20230803162303996.png" alt="image-20230803162303996"></p><p>点击确定</p><p><img src="/../images/image-20230803162342579.png" alt="image-20230803162342579"></p><p>依次输入信息,点击下一页</p><p><img src="/../images/image-20230803162410778.png" alt="image-20230803162410778"></p><p>建议选择32位, 点击下一步</p><p><img src="/../images/image-20230803162509857.png" alt="image-20230803162509857"></p><p>这里需要选择你的ItemPacket文件夹所在的路径</p><p><img src="/../images/image-20230803162625735.png" alt="image-20230803162625735"></p><p><img src="/../images/image-20230803162635063.png" alt="image-20230803162635063"></p><p>点击下一页</p><p><img src="/../images/image-20230803162701624.png" alt="image-20230803162701624"></p><p>向导, 点击下一页</p><p><img src="/../images/image-20230803162724109.png" alt="image-20230803162724109"></p><p>这里主题就默认的, 后续根据自己需要变更即可, 点击下一页</p><p><img src="/../images/image-20230803162807454.png" alt="image-20230803162807454"></p><p>语言默认即可, 如果是跨境项目可能有必要添加相应语言, 点击下一页</p><p><img src="/../images/image-20230803162905966.png" alt="image-20230803162905966"></p><p>这里根据你的项目中是否需要必要的运行库进行添加, 一般不做勾选, 点击下一页</p><p><img src="/../images/image-20230803163012222.png" alt="image-20230803163012222"></p><p>默认勾选,点击完成</p><p><img src="/../images/image-20230803163030882.png" alt="image-20230803163030882"></p><p>此时打包文件夹中的所有文件都已经保存到了打包项目中, 此时需要注意</p><p><img src="/../images/image-20230803163140060.png" alt="image-20230803163140060"></p><p>双击可执行文件</p><p><img src="/../images/image-20230803163217091.png" alt="image-20230803163217091"></p><p>覆盖这一项需要设置为始终覆盖现有文件. 点击确定</p><p>选择打包前设置</p><p><img src="/../images/image-20230803163347415.png" alt="image-20230803163347415"></p><p><img src="/../images/image-20230803163425435.png" alt="image-20230803163425435"></p><p>这里可以自定义设置安装包的图标, 另外还有七七八八一堆功能, 不再一一描述, 还需要亲们自己去摸索了. 点击确定</p><p>点击发布按钮</p><p><img src="/../images/image-20230803163648914.png" alt="image-20230803163648914"></p><p><img src="/../images/image-20230803163708809.png" alt="image-20230803163708809"></p><p>默认单一文件</p><p><img src="/../images/image-20230803163747218.png" alt="image-20230803163747218"></p><p>设置安装包的生成路径, 和安装包的命名, 点击下一步</p><p><img src="/../images/image-20230803163841106.png" alt="image-20230803163841106"></p><p><img src="/../images/image-20230803163853348.png" alt="image-20230803163853348"></p><p>点击完成</p><p><img src="/../images/image-20230803163916050.png" alt="image-20230803163916050"></p><p>项目打包成功, 这里不再展示安装</p>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> 软件打包 </tag>
            
            <tag> SetupFactory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建动态链接库.dll(Dynamic Link Library)</title>
      <link href="/2023/04/03/%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"/>
      <url>/2023/04/03/%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>本篇介绍如何使用qt创建一个动态链接库,并如何使用自己创建的动态库.</p><p><img src="/../images/image-20230803140633332.png" alt="image-20230803140633332"></p><hr><h2 id="创建动态链接库："><a href="#创建动态链接库：" class="headerlink" title="创建动态链接库："></a>创建动态链接库：</h2><p><img src="/../images/image-20230803141250596.png" alt="image-20230803141250596"></p><p><img src="/../images/image-20230803141350915.png" alt="image-20230803141350915"></p><p><img src="/../images/image-20230803141417812.png" alt="image-20230803141417812"></p><p><img src="/../images/image-20230803141433542.png" alt="image-20230803141433542"></p><p><img src="/../images/image-20230803141451031.png" alt="image-20230803141451031"></p><p><img src="/../images/image-20230803141543224.png" alt="image-20230803141543224"></p><p><img src="/../images/image-20230803141559439.png" alt="image-20230803141559439"></p><p>项目创建完成之后可以看到三个文件,这里库函数中的功能函数要写在mydll.h和mydll.cpp中,如果比较复杂可以添加新的.h&#x2F;.cpp, 下面以此为例</p><p><img src="/../images/image-20230803141652147.png" alt="image-20230803141652147"></p><p>首先在mydll.h中声明我们需要封装的功能函数并在cpp中实现并写入功能</p><p><img src="/../images/image-20230803142324755.png" alt="image-20230803142324755"></p><p><img src="/../images/image-20230803142538825.png" alt="image-20230803142538825"></p><p>此时动态库已经编辑完成,保存之后构建项目</p><p><img src="/../images/image-20230803142726500.png" alt="image-20230803142726500"></p><p>构建完成之后找到构建目录,从对应的构建方式下找到对应的.dll文件</p><p><img src="/../images/image-20230803142905635.png" alt="image-20230803142905635"></p><p><img src="/../images/image-20230803142938036.png" alt="image-20230803142938036"></p><p>此时动态链接库文件已经生成完成,接下来讲解如何调用我们生成的动态库</p><h2 id="调用动态链接库"><a href="#调用动态链接库" class="headerlink" title="调用动态链接库:"></a>调用动态链接库:</h2><p>要调用自定义的动态库, 首先创建一个默认的qt项目,这里不再展示创建过程</p><p><img src="/../images/image-20230803143436798.png" alt="image-20230803143436798"></p><p>项目创建完成之后,首先进入项目所在的路径,穿件两个文件夹,分别命名为lib和include, 这里lib文件夹中存放.dll文件, include文件夹中把我们生成动态库文件的项目中的头文件.h放进来. </p><p><img src="/../images/image-20230803143700235.png" alt="image-20230803143700235"></p><p><img src="/../images/image-20230803143811304.png" alt="image-20230803143811304"></p><p><img src="/../images/image-20230803143833559.png" alt="image-20230803143833559"></p><p>完成以上操作之后, 回到QT我们创建的项目, 进入.pro文件, 在文件中添加我们创建的路径信息</p><p><img src="/../images/image-20230803144253959.png" alt="image-20230803144253959"></p><p><img src="/../images/image-20230803144226004.png" alt="image-20230803144226004"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加include文件夹</span></span><br><span class="line">INCLUDEPATH += $$PWD/include</span><br><span class="line"><span class="comment">//添加lib文件夹, 并加入名为&quot;mydll&quot;的.dll文件, 这里需要注意语法-l后追加文件名</span></span><br><span class="line">LIBS += -L$$PWD/lib -lmydll</span><br></pre></td></tr></table></figure><p>以上就完成了动态库的路径配置, 接下里是动态库的调用</p><p><img src="/../images/image-20230803145034953.png" alt="image-20230803145034953"></p><p>完成之后运行项目项目</p><p><img src="/../images/image-20230803145218801.png" alt="image-20230803145218801"></p><p>这里我们就成功的在项目中调用了自建的动态链接库</p>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> 动态链接库 </tag>
            
            <tag> .dll </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态链接库.dll(Dynamic Link Library)</title>
      <link href="/2023/03/11/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2023/03/11/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>在一些有特定需求对的项目中可能会用到动态链接库, 如果是标准的动态链接库我们找到它对应的接口调用其功能即可, 而在一些特定的情况下我们可能需要自定义动态链接库. 本篇主要阐释动态链接库的基本概念,后续我会更新如何自定义一个动态链接库文件,以及如何在自己的项目中调用自定义的动态链接库.</p><hr><h2 id="动态链接库："><a href="#动态链接库：" class="headerlink" title="动态链接库："></a>动态链接库：</h2><h3 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h3><p>动态链接库（Dynamic Link Library，DLL）是一种在Windows操作系统中常见的可执行文件格式，用于存储可被应用程序动态加载和使用的代码和数据。与静态链接库不同，动态链接库在程序运行时才会被加载，并且可以被多个应用程序共享。</p><p>以下是动态链接库的一些特点和优势：</p><ol><li><p>动态加载：动态链接库可以在程序运行时通过操作系统的动态链接机制被加载到内存中。这意味着只有在需要使用库中的函数或符号时才会加载，可以减少内存占用和启动时间。</p></li><li><p>共享使用：多个应用程序可以同时使用同一个动态链接库。这样可以避免代码的重复，节省存储空间，并且可以实现代码的统一更新和维护。</p></li><li><p>动态更新：由于动态链接库是独立于应用程序的，因此可以方便地对库进行更新和升级。应用程序无需重新编译和发布，只需要替换库文件即可。</p></li><li><p>模块化设计：动态链接库可以将功能模块化，使得代码更易于组织、维护和复用。通过将相关的功能封装在动态链接库中，可以实现高内聚、低耦合的设计。</p></li><li><p>符号解析：动态链接库中的函数和符号可以被应用程序动态解析和调用。通过获取函数指针或符号地址，应用程序可以直接调用库中的函数，实现与库的交互和功能扩展。</p></li></ol><p>动态链接库在实际应用中有广泛的应用场景，例如插件系统、共享组件、第三方库的使用等。它们提供了一种灵活、高效的方式来扩展和增强应用程序的功能。同时，动态链接库也需要注意版本兼容性、依赖关系等问题，以确保应用程序能够正确加载和使用库。</p><h3 id="包含信息"><a href="#包含信息" class="headerlink" title="包含信息"></a>包含信息</h3><p>动态链接库（Dynamic Link Library，DLL）是一种可被多个程序共享使用的代码和数据的集合。在Windows操作系统中，DLL文件通常包含以下几类信息：</p><ol><li><p>导出函数：DLL文件可以包含一个或多个可供其他程序调用的函数。这些函数被称为导出函数，可以通过函数名来调用。导出函数定义了DLL提供给其他程序的接口。</p></li><li><p>导入函数：DLL文件可以引用其他DLL文件或操作系统提供的函数。这些函数被称为导入函数，可以在DLL文件中使用，但是它们的实现在其他DLL文件或操作系统中。导入函数定义了DLL依赖的接口。</p></li><li><p>数据段：DLL文件可以包含一些静态数据，这些数据可以被多个程序共享。这些数据可以存储全局变量、常量、配置信息等。</p></li><li><p>资源：DLL文件可以包含一些资源，例如图标、位图、字符串等。这些资源可以在程序运行时被其他程序或操作系统使用。</p></li></ol><p>DLL文件的内部信息通常以一种特定的格式进行存储和组织。在Windows操作系统中，DLL文件的格式遵循PE（Portable Executable）格式，这是一种可移植可执行文件的格式。PE格式定义了DLL文件的头部信息、节区信息、导入表、导出表、符号表等。这些信息描述了DLL的结构和内容，使得操作系统和其他程序能够正确加载和使用DLL文件中的代码和数据。</p><p>需要注意的是，DLL文件的具体格式和内容可能会因不同的操作系统或编程语言而有所差异，上述信息仅是一般情况下的常见特征。</p><h3 id="生成步骤"><a href="#生成步骤" class="headerlink" title="生成步骤"></a>生成步骤</h3><p>要生成一个动态链接库（DLL），你可以按照以下步骤进行操作：</p><ol><li><p>选择编程语言：首先，选择你熟悉的编程语言。常用的编程语言如C&#x2F;C++、C#、Java等都提供了生成DLL的支持。</p></li><li><p>编写代码：使用你选择的编程语言编写DLL代码。在代码中定义导出函数（可供其他程序调用的函数）和其他需要共享的数据。</p></li><li><p>声明导出函数：在DLL代码中，需要使用适当的语法和关键字来声明导出函数。这可以告诉编译器将这些函数作为DLL的导出函数进行处理。</p></li><li><p>编译代码：使用编译器将DLL代码编译为二进制文件。编译时，应该指定生成动态链接库的选项，以确保生成正确的文件类型。</p></li><li><p>链接库文件：将编译生成的二进制文件链接为DLL文件。这通常需要使用特定的工具或命令来完成。链接过程将把DLL文件与所需的运行时库和其他依赖项进行关联。</p></li><li><p>测试和调试：编译和链接成功后，你可以对生成的DLL文件进行测试和调试。确保导出函数的功能正确，并且DLL在其他程序中能够正常加载和使用。</p></li></ol><p>需要注意的是，生成DLL的具体步骤可能因所使用的编程语言和开发环境而有所差异。建议参考相应编程语言的文档或教程，以了解特定语言和工具的详细操作步骤。</p><p>以下是使用C++语言生成动态链接库（DLL）的基本示例：</p><ol><li><p>创建一个新的C++源文件，例如example.cpp。</p></li><li><p>在example.cpp中编写DLL的代码，包括导出函数和其他需要共享的数据。以下是一个简单的示例：</p></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function"><span class="type">int</span> <span class="title">AddNumbers</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他需要共享的数据</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="type">int</span> sharedData = <span class="number">42</span>;</span><br></pre></td></tr></table></figure><p>在此示例中，AddNumbers函数是一个导出函数，可以被其他程序调用。sharedData是一个共享的整数变量。</p><ol start="3"><li>使用C++编译器（如g++或Visual C++）编译源代码，并将其生成为DLL文件。以下是使用g++编译器的示例命令行：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ -shared -o example.dll example.cpp</span><br></pre></td></tr></table></figure><p>此命令将源文件example.cpp编译为名为example.dll的动态链接库文件。</p><ol start="4"><li>编译成功后，将生成的example.dll文件与所需的运行时库和其他依赖项一起使用。你可以在其他C++程序中加载和调用该DLL提供的函数，或让其他语言的程序调用。</li></ol><p>请注意，在不同的操作系统和编译环境下，生成DLL的具体命令和选项可能会有所不同。建议参考你所使用的编译器和开发环境的文档，以了解相应的生成DLL方法和选项。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 动态链接库 </tag>
            
            <tag> .dll </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程_join()</title>
      <link href="/2023/02/15/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B_join()/"/>
      <url>/2023/02/15/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B_join()/</url>
      
        <content type="html"><![CDATA[<h2 id="join"><a href="#join" class="headerlink" title="join()"></a><strong>join()</strong></h2><p>​假设存在一个主线程中有一个子线程，主线程执行周期为500ms，而子线程中的业务逻辑稍微复杂一点，执行所用的时间周期更长大概需要800ms。那么在中情况下，如果任凭事情发展，最终的结果会是，子线程的业务逻辑还未执行完毕就随着主线程的结束而直接终止了。为了防止这种情况的发生就有了join()函数。</p><p>​使用方法：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> num, string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;num: &quot;</span> </span><br><span class="line">             &lt;&lt; num &lt;&lt; <span class="string">&quot;, str: &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">download1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 模拟下载, 总共耗时500ms，阻塞线程500ms</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程1: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">download2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 模拟下载, 总共耗时300ms，阻塞线程300ms</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">300</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程2: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;....主线程来了....&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* cout &lt;&lt; &quot;主线程的线程ID: &quot; &lt;&lt; this_thread::get_id() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    thread t(func, 123, &quot;abc&quot;);</span></span><br><span class="line"><span class="comment">    // 需要注明的是，thread声明的对象应含有这种形式：</span></span><br><span class="line"><span class="comment">    // 首先是函数的名称，然后依次传入该函数对应类型的函数参数    </span></span><br><span class="line"><span class="comment">    thread t1(func1);</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &quot;线程t 的线程ID: &quot; &lt;&lt; t.get_id() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &quot;线程t1的线程ID: &quot; &lt;&lt; t1.get_id() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    t.join();</span></span><br><span class="line"><span class="comment">    t1.join();*/</span></span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(download1)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(download2)</span></span>;</span><br><span class="line">    <span class="comment">// 阻塞主线程，等待所有子线程任务执行完毕再继续向下执行</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">doSomething</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如代码中，通过声明的类的对象调用join()函数实现线程阻塞。输出的结果为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子线程2: 72540</span></span><br><span class="line"><span class="comment">// 子线程1: 79776</span></span><br><span class="line"><span class="comment">// ....主线程来了....</span></span><br></pre></td></tr></table></figure><p>通过输出结果可以看出，主线程是在子线程调用完毕之后再调用的，说明主线程已经被阻塞执行，确保了子线程的完整运行。</p><p><u>需要注意的是：在阻塞线程的时候，一定要注意我们阻塞的是哪个线程，线程在哪个线程被执行，就阻塞哪个线程。</u></p><p>以上(*￣︶￣)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> C++11 </tag>
            
            <tag> C++ </tag>
            
            <tag> join() </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程_datach()</title>
      <link href="/2023/02/13/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B_detach()/"/>
      <url>/2023/02/13/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B_detach()/</url>
      
        <content type="html"><![CDATA[<h2 id="detach"><a href="#detach" class="headerlink" title="detach()"></a><strong>detach()</strong></h2><p>​“从前一户人家的孩子非常叛逆，家里人已经管不了他了，他离家出走开始了自己独立的生活，后来家里触犯了律法，被满门抄斩，这个离家出走的孩子也依然会被株连。”</p><p>​存在某一种情况，我们需要单独执行某一个线程下的子线程，而且需要在执行这个子线程时，不会影响原有的线程。这个时候就需要用到线程分离函数detach()</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> num, string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;num: &quot;</span> </span><br><span class="line">             &lt;&lt; num &lt;&lt; <span class="string">&quot;, str: &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">download1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 模拟下载, 总共耗时500ms，阻塞线程500ms</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程1: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">download2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 模拟下载, 总共耗时300ms，阻塞线程300ms</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">300</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程2: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;....主线程来了....&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程的线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func, <span class="number">123</span>, <span class="string">&quot;abc&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 需要注明的是，thread声明的对象应含有这种形式：</span></span><br><span class="line">    <span class="comment">// 首先是函数的名称，然后依次传入该函数对应类型的函数参数    </span></span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程t 的线程ID: &quot;</span> &lt;&lt; t.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程t1的线程ID: &quot;</span> &lt;&lt; t1.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">    t1.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="comment">// 让主线程休眠，等待子线程执行结束</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">second</span>(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：线程分离不会阻塞线程，子主线程分离之后，在主线程中就不能再对该子线程进行任何控制了，比如：通过 join () 阻塞主线程等待子线程中的任务执行完毕，或者调用 get_id () 获取子线程的线程 ID等。有利就有弊，鱼和熊掌不可兼得，建议使用 join ()。</p><p>以上(*￣︶￣)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> detach() </tag>
            
            <tag> C++11 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Qt中.pri文件</title>
      <link href="/2023/01/17/%E5%85%B3%E4%BA%8EQt%E4%B8%AD.pri%E6%96%87%E4%BB%B6/"/>
      <url>/2023/01/17/%E5%85%B3%E4%BA%8EQt%E4%B8%AD.pri%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>​通过Qt创建的项目中，例如通常情况下的小项目，较少用到.pri文件。但是在中型或大型项目当中，需要把项目中的各个功能模块化，分隔开独立开发。这个时候就需要用到.pri文件取分支项目。以下是.pri的创建流程：</p><ol><li><p>首先在创建好的项目中右键.pro文件→在Explorer中打开，打开项目所在路径</p></li><li><p>在项目所在的路径中新建一个文件夹并命名demo</p></li><li><p>在文件夹中新建txt文件，并重命名为demo.pri</p></li><li><p>回到Qt，在Qt界面中的pro文件中添加</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">include</span>($$PWD/demo/demo.pri)</span><br><span class="line"><span class="comment">//$$：环境变量名</span></span><br></pre></td></tr></table></figure></li><li><p>添加完成后保存，等待一会儿就可以看到，项目中新添加了新的demo类目，其中存在demo.pri文件</p></li><li><p>这样分化的类目的基本雏形就存在了，接下来是在这个类目中添加新的.h&#x2F;.cpp和ui文件(注：并非所有的类目都需要ui文件，这里会分开说明)</p></li><li><p>a.如果不需要ui文件：右击新添加的类目，从选项中选择添加新文件，选择“C&#x2F;C++”，然后按照正常的项目创建流程创建即可；</p><p>b.如果需要ui文件：依然是单击右键，选择添加新文件，选择”Qt”，在这一类目中选择”Qt 设计器界面类”，然后按照正常流程创建即可</p></li><li><p>以上这两种方式在创建完成时，会在.pri文件中直接生成引用源，不需要再次声明</p><h3 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题:"></a>需要注意的问题:</h3><p>​在项目的中涉及到添加.pri文件的时候, 一般情况下我们的需求可能就是把某几组 .h&#x2F;cpp&#x2F;.ui 文件放置在同一个pri下方便管理, 这里可能会涉及到一些已有的 .h&#x2F;cpp&#x2F;.ui 文件需要转移到 .pri 目录下, 方法是直接逐个拖动过去即可, 在这之后变更调用这些文件 ( 如.h文件 ) 的位置的相对路径即可.</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Qt </tag>
            
            <tag> .pri </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Qt中.pro文件</title>
      <link href="/2023/01/17/%E5%85%B3%E4%BA%8EQt%E4%B8%AD.pro%E6%96%87%E4%BB%B6/"/>
      <url>/2023/01/17/%E5%85%B3%E4%BA%8EQt%E4%B8%AD.pro%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>本文主要列举说明在qt中新建项目生成的pro文件中，所涉及到的一些类目，可能不全，后续会再补充。</p><ol><li>QT +&#x3D; 是添加QT项目需要的模块 QT-&#x3D;是排除或者移除某个模块</li><li>HEADERS：.h文件</li><li>SOURCES：.cpp文件</li><li>FORMS：指定需要uic处理的ui文件</li><li>RESOURCES：指定需要rcc处理的qrc文件</li><li>DEFINES：指定预定义预处理器符号</li><li>INCLUDEPATH：指定C++编译器搜索头文件路径</li><li>LIBS：指定工程要链接的库</li><li>CONFIG：指定工程配置和编译参数</li><li>QT：指定工程所要使用的Qt模块</li><li>VERSION：指定目标库版本号</li><li>TARGET：指定可执行文件或库的基本文件名，默认为当前目录名</li><li>DESTDIR：指定可执行文件放置的目录</li><li>DLLDESTDIR：指定目标库文件放置的目录</li><li>RC_ICONS：添加icon</li><li>include:引入头文件或者pri文件</li><li>PWD:指的是当前正在解析的.pro文件的目录的完整路径</li><li>OUT_PWD:指的是qmake生成的Makefile的目录的完整路径</li><li>message:pro文件里面的打印输出</li><li>win32：条件编译</li></ol><h3 id="其中几个比较重要的说明："><a href="#其中几个比较重要的说明：" class="headerlink" title="其中几个比较重要的说明："></a>其中几个比较重要的说明：</h3><p>LIBS：指定工程要链接的库</p><p>LIBS 相对来说是比较重要的，因为在一些开发当中经常需要添加第三方库。这个时候就需要用LIBS来引入第三方库到工程中</p><p>LIBS的格式：    LIBS +&#x3D; -L路径 库名字</p><p>eg:            LIBS +&#x3D; -L$$PWD&#x2F;Demo_Pri&#x2F; -lvisa32d<br>#######################################################################################<br>-L :表示Local 即库的位置<br>-l :表示库本身 即库的名称<br>[注意不需要加dll&#x2F;so等后缀(QT跨平台比较强，后缀名为根据平台自动选择)]<br>####################################################################################### </p><p>自动拷贝<a href="https://so.csdn.net/so/search?q=dll%E6%96%87%E4%BB%B6&spm=1001.2101.3001.7020">dll文件</a>的方法：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">法<span class="number">1</span>：</span><br><span class="line">#利用cpoys 这个命令</span><br><span class="line">cp_kk.files += \</span><br><span class="line">            chartdir50.dll</span><br><span class="line">cp_kk.path  += $$OUT_PWD/release</span><br><span class="line">COPIES +=  cp_kk</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">法<span class="number">2</span>：</span><br><span class="line">#QMAKE_SUBSTITUTES</span><br><span class="line">DLL.input =  chartdir50.dll</span><br><span class="line">DLL.output = $$OUT_PWD/release/chartdir50.dll</span><br><span class="line">DLL.CONFIG = verbatim # 完全复制</span><br><span class="line">QMAKE_SUBSTITUTES += DLL</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Qt </tag>
            
            <tag> .pro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物联网智能家居-智能开关</title>
      <link href="/2022/12/25/%E7%89%A9%E8%81%94%E7%BD%91%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85-%E6%99%BA%E8%83%BD%E5%BC%80%E5%85%B3/"/>
      <url>/2022/12/25/%E7%89%A9%E8%81%94%E7%BD%91%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85-%E6%99%BA%E8%83%BD%E5%BC%80%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>这几天阳性在家，这个智能开关是小半个多月之前就计划制作了。本身并不是很难的东西。不过中间买错了东西，耽误了点时间，刚好赶上休息时间东西到了，也就把东西做出来了。</p><hr><h2 id="首先是硬件材料的准备："><a href="#首先是硬件材料的准备：" class="headerlink" title="首先是硬件材料的准备："></a>首先是硬件材料的准备：</h2><p>基于ESP8266的ESP-01、Relay模块、CH340C</p><p>就这三个东西，在拼多多上直接买都有，一共下来大概不到20块钱</p><hr><h2 id="接下来是环境的配置："><a href="#接下来是环境的配置：" class="headerlink" title="接下来是环境的配置："></a>接下来是环境的配置：</h2><p>1.首先是安装Arduino(这个没什么难度，注意自己把安装的分区分好，别放C盘，路径上最好是别有中文和空格)；</p><p>2.在手机上下载一个blinker，这个是人家做好的物联网app，就直接拿来用了，以后还是打算自己写一个哈哈。</p><p>3.只安装好Arduino还不行，需要在软件中补充开发板信息，找到<u>开发板管理器</u>，然后搜索ESP8266，很有可能找不到，这个时候你需要首先在<u>首选项</u>里的<u>其他开发板管理器地址</u>中添加<a href="http://arduino.esp8266.com/stable/package_esp8266com_index.json%EF%BC%8C%E7%84%B6%E5%90%8E%E4%BF%9D%E5%AD%98%E4%B8%80%E4%B8%8B%EF%BC%8C%E5%86%8D%E6%B7%BB%E5%8A%A0%E5%BC%80%E5%8F%91%E6%9D%BF%E8%AF%95%E8%AF%95%E3%80%82%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E9%9D%9E%E5%B8%B8%E6%85%A2%E3%80%82%E5%A6%82%E6%9E%9C%E5%AB%8C%E6%85%A2%E5%8F%AF%E4%BB%A5%E5%8E%BBGit%E4%B8%8A%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%EF%BC%8C%E6%94%BE%E5%9C%A8%E7%9B%AE%E6%A0%87%E7%9B%AE%E5%BD%95%E9%87%8C%E5%8D%B3%E5%8F%AF%E3%80%82">http://arduino.esp8266.com/stable/package_esp8266com_index.json，然后保存一下，再添加开发板试试。这个过程非常慢。如果嫌慢可以去Git上直接下载，放在目标目录里即可。</a></p><p>4.完成以上步骤后，还差一个步骤。我们在使用blinker这个app的时候，在烧录的代码里需要用到&lt;Blinker.h&gt;的头文件的库函数。这个也需要我们在Arduino中自己搜索添加。在管理库这个选项中，搜索blinker，有两个，我都下载了哈哈，反正没多大。</p><p>5.接下来就可以烧录了。直接上代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BLINKER_WIFI</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Blinker.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> auth[] = <span class="string">&quot;75*****27&quot;</span>; <span class="comment">//点灯科技设备KEY</span></span><br><span class="line"><span class="type">char</span> ssid[] = <span class="string">&quot;A**X&quot;</span>;  <span class="comment">//WIFI名称-只支持2.4G</span></span><br><span class="line"><span class="type">char</span> pswd[] = <span class="string">&quot;B******6&quot;</span>; <span class="comment">//WIFI密码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bt1 5</span></span><br><span class="line"><span class="comment">// #define bt2 4</span></span><br><span class="line"><span class="comment">// #define bt3 0</span></span><br><span class="line"><span class="comment">// #define bt4 2</span></span><br><span class="line"><span class="comment">// 新建组件对象</span></span><br><span class="line"><span class="function">BlinkerButton <span class="title">Button1</span><span class="params">(<span class="string">&quot;btn1&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按下按键即会执行该函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">button1_callback</span><span class="params">(<span class="type">const</span> String &amp; state)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">BLINKER_LOG</span>(<span class="string">&quot;get button state: &quot;</span>, state);</span><br><span class="line">  <span class="keyword">if</span> (state == <span class="string">&quot;on&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">digitalWrite</span>(bt1, LOW);</span><br><span class="line">    <span class="comment">// 反馈开关状态</span></span><br><span class="line">    Button1.<span class="built_in">print</span>(<span class="string">&quot;on&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="string">&quot;off&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">digitalWrite</span>(bt1, HIGH);</span><br><span class="line">    <span class="comment">// 反馈开关状态</span></span><br><span class="line">    Button1.<span class="built_in">print</span>(<span class="string">&quot;off&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化串口</span></span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line">  <span class="comment">// 初始化有LED的IO</span></span><br><span class="line">  <span class="built_in">pinMode</span>(bt1, OUTPUT);</span><br><span class="line">  <span class="built_in">digitalWrite</span>(bt1, HIGH);</span><br><span class="line">  <span class="comment">// 初始化blinker</span></span><br><span class="line">  Blinker.<span class="built_in">begin</span>(auth, ssid, pswd);</span><br><span class="line">  Button1.<span class="built_in">attach</span>(button1_callback);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Blinker.<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就基本完成了，接上自己家里的灯就可以使用了。之后我会再补充和完善一些功能。最近写的还有不少笔记没来得及发出来，最近一两周看如果有时间的话我就发出来。</p>]]></content>
      
      
      
        <tags>
            
            <tag> IoT </tag>
            
            <tag> ESP8266 </tag>
            
            <tag> Arduino </tag>
            
            <tag> blinker </tag>
            
            <tag> 智能家居 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QPushButton/QLabel鼠标悬浮（划过， hover）、选中（单击， pressed）状态下更换图标样式</title>
      <link href="/2022/12/03/QPushButtonQLabel%E9%BC%A0%E6%A0%87%E6%82%AC%E6%B5%AE(%E5%88%92%E8%BF%87%EF%BC%8C%20hover)%E9%80%89%E4%B8%AD(%E5%8D%95%E5%87%BB,pressed)%E7%8A%B6%E6%80%81%E4%B8%8B%E6%9B%B4%E6%8D%A2%E5%9B%BE%E6%A0%87%E6%A0%B7%E5%BC%8F/"/>
      <url>/2022/12/03/QPushButtonQLabel%E9%BC%A0%E6%A0%87%E6%82%AC%E6%B5%AE(%E5%88%92%E8%BF%87%EF%BC%8C%20hover)%E9%80%89%E4%B8%AD(%E5%8D%95%E5%87%BB,pressed)%E7%8A%B6%E6%80%81%E4%B8%8B%E6%9B%B4%E6%8D%A2%E5%9B%BE%E6%A0%87%E6%A0%B7%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>有三种方式：1.样式表2.event()3.evenfilter()</p><ol><li><h2 id="样式表"><a href="#样式表" class="headerlink" title="样式表"></a>样式表</h2><p>第一种方法：在样式表中设置 border-image（在网上看到有人使用 background-image 的，不推荐，因为那样的话图标大小是不会自动缩放的，有兴趣的可以试一下）。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QPushButton *button1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line">button1-&gt;<span class="built_in">setFixedSize</span>(<span class="number">30</span>, <span class="number">30</span>);</span><br><span class="line">button1-&gt;<span class="built_in">setFlat</span>(<span class="literal">true</span>);</span><br><span class="line">button1-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QPushButton&#123;border-image:url(:/listBar_Icon/add.png);&#125;&quot;</span></span><br><span class="line">                       <span class="string">&quot;QPushButton:hover&#123;border-image:url(:/listBar_Icon/add_hover.png);&#125;&quot;</span></span><br><span class="line">                       <span class="string">&quot;QPushButton:pressed&#123;border-image:url(:/listBar_Icon/add_pressed.png);&#125;&quot;</span></span><br><span class="line">                       );</span><br></pre></td></tr></table></figure><p>优点 ：简单方便。<br>缺点 : border-image 会随着 QPushButton 的大小尺寸变化（图标会填充整个按钮）。上面的例子中按钮形状和图标素材都是正方形的，所以效果不错。如果 QPushButton 只显示图标的话用这种方法比较好，如果需要添加文字而导致按钮形状和素材不同，这种方法则不可取。</p></li><li><h2 id="event"><a href="#event" class="headerlink" title="event()"></a>event()</h2><p>第二种方法：继承 QPushButton，重写 event 事件。效果和第一个 gif 相同。</p><p>MyPushButton.h</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPushButton</span> : <span class="keyword">public</span> QPushButton</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyPushButton</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setUpIcon</span><span class="params">(<span class="type">const</span> QIcon &amp;icon, <span class="type">const</span> QIcon &amp;icon_hover, <span class="type">const</span> QIcon &amp;icon_pressed)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">event</span><span class="params">(QEvent *event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QIcon Img, Img_hover, Img_pressed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>MyPushButton.c</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyPushButton::<span class="built_in">MyPushButton</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QPushButton</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPushButton::setUpIcon</span><span class="params">(<span class="type">const</span> QIcon &amp;icon, <span class="type">const</span> QIcon &amp;icon_hover, <span class="type">const</span> QIcon &amp;icon_pressed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Img = icon;</span><br><span class="line">    Img_hover = icon_hover;</span><br><span class="line">    Img_pressed = icon_pressed;</span><br><span class="line">    <span class="built_in">setIcon</span>(Img);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyPushButton::event</span><span class="params">(QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event-&gt;<span class="built_in">type</span>()) &#123;</span><br><span class="line">    <span class="keyword">case</span> QEvent::Enter:</span><br><span class="line">        <span class="built_in">setIcon</span>(Img_hover);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QEvent::Leave:</span><br><span class="line">        <span class="built_in">setIcon</span>(Img);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QEvent::MouseButtonPress:</span><br><span class="line">        <span class="built_in">setIcon</span>(Img_pressed);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QEvent::MouseButtonRelease:</span><br><span class="line">        <span class="built_in">setIcon</span>(Img_hover);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QPushButton::<span class="built_in">event</span>(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 MyPushButton</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyPushButton *button2 = <span class="keyword">new</span> <span class="built_in">MyPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line">button2-&gt;<span class="built_in">setFixedSize</span>(<span class="number">60</span>, <span class="number">30</span>);</span><br><span class="line">button2-&gt;<span class="built_in">setFlat</span>(<span class="literal">true</span>);</span><br><span class="line">button2-&gt;<span class="built_in">setUpIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/listBar_Icon/add.png&quot;</span>), <span class="built_in">QIcon</span>(<span class="string">&quot;:/listBar_Icon/add_hover.png&quot;</span>), <span class="built_in">QIcon</span>(<span class="string">&quot;:/listBar_Icon/add_pressed.png&quot;</span>));</span><br><span class="line">button2-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QPushButton&#123;border:0px solid rgba(0, 0, 0, 255);&#125;&quot;</span>);</span><br><span class="line">button2-&gt;<span class="built_in">setIconSize</span>(<span class="built_in">QSize</span>(<span class="number">30</span>, <span class="number">30</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>优点 ：图标显示效果不会受到按钮尺寸影响，只由setIconSize(QSize)控制。</li><li>缺点 ：有点复杂</li></ul></li><li><h2 id="evenfilter"><a href="#evenfilter" class="headerlink" title="evenfilter()"></a>evenfilter()</h2><p>第三种方法：原理及优缺点和第二种方法相同，只是不需要继承 QPushButton，而是重写主窗口的事件过滤器。</p><p>主窗口.h：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">test</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPushButton *button3 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initUi</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *obj, QEvent *event)</span> <span class="keyword">override</span></span>;  <span class="comment">//事件过滤</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主窗口.c：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">test::<span class="built_in">test</span>(QWidget *parent) : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">initUi</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test::initUi</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    button3 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line">    button3-&gt;<span class="built_in">setFixedSize</span>(<span class="number">30</span>, <span class="number">30</span>);</span><br><span class="line">    button3-&gt;<span class="built_in">setFlat</span>(<span class="literal">true</span>);</span><br><span class="line">    button3-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/listBar_Icon/add.png&quot;</span>));</span><br><span class="line">    button3-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QPushButton&#123;border:0px solid rgba(0, 0, 0, 255);&#125;&quot;</span>);</span><br><span class="line">    button3-&gt;<span class="built_in">setIconSize</span>(<span class="built_in">QSize</span>(<span class="number">30</span>, <span class="number">30</span>));</span><br><span class="line">    button3-&gt;<span class="built_in">installEventFilter</span>(<span class="keyword">this</span>);  <span class="comment">//安装事件过滤器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">test::eventFilter</span><span class="params">(QObject *obj, QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event-&gt;<span class="built_in">type</span>()) &#123;</span><br><span class="line">    <span class="keyword">case</span> QEvent::HoverEnter:</span><br><span class="line">        <span class="keyword">if</span>(obj == button3)</span><br><span class="line">            button3-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/listBar_Icon/add_hover.png&quot;</span>));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QEvent::HoverLeave:</span><br><span class="line">        <span class="keyword">if</span>(obj == button3)</span><br><span class="line">            button3-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/listBar_Icon/add.png&quot;</span>));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QEvent::MouseButtonPress:</span><br><span class="line">        <span class="keyword">if</span>(obj == button3)</span><br><span class="line">            button3-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/listBar_Icon/add_pressed.png&quot;</span>));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QEvent::MouseButtonRelease:</span><br><span class="line">        <span class="keyword">if</span>(obj == button3)</span><br><span class="line">            button3-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/listBar_Icon/add_hover.png&quot;</span>));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QWidget::<span class="built_in">eventFilter</span>(obj, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>如果需要在按钮中添加文字，那么只能使用后面两种方法。 QLabel和QPushButton差不多，不再赘述。</p><p>以上，(*￣︶￣)</p>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> QPushButton </tag>
            
            <tag> QLabel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈你对拷贝构造函数和赋值运算符的认识</title>
      <link href="/2022/11/23/%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E8%AE%A4%E8%AF%86/"/>
      <url>/2022/11/23/%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E8%AE%A4%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>我们在通过类定义一个对象</p><p>比如:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">stu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">stu</span>(<span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">m_age = a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过如下方式产生一个拷贝构造函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">stu <span class="title">p1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">stu <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br></pre></td></tr></table></figure><p>这样，p2就是通过编译器为我们自动进行了一次浅拷贝</p><p>[待补充…]</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
            <tag> 面试题 </tag>
            
            <tag> 拷贝构造函数 </tag>
            
            <tag> 函数重载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>static关键字在C语言和C++中的使用及区别</title>
      <link href="/2022/11/23/static%E5%85%B3%E9%94%AE%E5%AD%97%E5%9C%A8C%E8%AF%AD%E8%A8%80%E5%92%8CC++%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/11/23/static%E5%85%B3%E9%94%AE%E5%AD%97%E5%9C%A8C%E8%AF%AD%E8%A8%80%E5%92%8CC++%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="一、总述"><a href="#一、总述" class="headerlink" title="一、总述"></a>一、总述</h2><p>由于C++兼容C语言，所以<strong>static在C语言中的用法对于C++是同样适用的</strong>。两者的不同就是C++中多出来的特性，而这些特性与C++面线对象的特性有关。</p><h2 id="二、static在C语言中的作用（C-通用）"><a href="#二、static在C语言中的作用（C-通用）" class="headerlink" title="二、static在C语言中的作用（C++通用）"></a>二、static在C语言中的作用（C++通用）</h2><h3 id="1、修饰变量"><a href="#1、修饰变量" class="headerlink" title="1、修饰变量"></a>1、修饰变量</h3><h4 id="a、修饰全局变量（全局变量与静态全局变量的对比）"><a href="#a、修饰全局变量（全局变量与静态全局变量的对比）" class="headerlink" title="a、修饰全局变量（全局变量与静态全局变量的对比）"></a>a、修饰全局变量（全局变量与静态全局变量的对比）</h4><p>​修饰全局变量：作用域仅限于变量被定义的文件中，其他文件即使用extern声明也无法直接使用此变量，extern用法详见这里。（可以间接访问，即通过本文件的非static函数返回static变量的值，类似于C++类中的private变量外界没有权限访问，但是可以通过public函数返回private变量的值）。<br>​对比：全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同，且都只初始化一次，但静态全局变量对其他文件不可见，全局变量是可见的。<br>​总结：把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。  </p><h4 id="b、修饰局部变量"><a href="#b、修饰局部变量" class="headerlink" title="b、修饰局部变量"></a>b、修饰局部变量</h4><p>​修饰局部变量：在函数内定义的局部变量被修饰，可以延长变生命周期，但是作用域不变，只初始化一次。<br>​对比：普通局部变量定义后，出了作用域就会被释放，静态局部变量生命周期到程序结束才结束。<br>​总结：把局部变量改变为静态变量后是改变了它的存储方式，让静态局部变量出了作用域依然存在，到程序结束，生命周期才结束。</p><h3 id="2、修饰函数"><a href="#2、修饰函数" class="headerlink" title="2、修饰函数"></a>2、修饰函数</h3><p>和全局变量一样，函数的定义和声明默认情况下是extern的，但静态函数只是在声明它的文件当中可见，不能被其他文件所用。</p><h2 id="三、static在C-中的作用"><a href="#三、static在C-中的作用" class="headerlink" title="三、static在C++中的作用"></a>三、static在C++中的作用</h2><p>C+ +重用了这个关键字，并赋予它与前面不同的含义：表示属于一个类而不是属于此类的任何特定对象的变量和函数。</p><h3 id="1、静态数据成员"><a href="#1、静态数据成员" class="headerlink" title="1、静态数据成员"></a>1、静态数据成员</h3><p>静态数据成员是属于整个类的，而不是属于某个对象。即不管实例多少个对象，它们都公用一个静态数据成员（如：使用静态数据成员统计类已经实例化了多少对象）。</p><p>在c++中，普通数据成员在构造函数的函数体或初始化表中初始化；常量数据成员(const int a )必须在构造函数的初始化表中初始化（const对象或引用只能初始化但是不能赋值。构造函数的函数体内只能做赋值而不是初始化）；而静态数据成员(static int b )则必须在类外初始化（int 类名::b&#x3D;100），这是因为静态数据成员不属于任何一个对象，而是属于整个类的。</p><h3 id="2、静态成员函数"><a href="#2、静态成员函数" class="headerlink" title="2、静态成员函数"></a>2、静态成员函数</h3><p>静态成员函数是属于整个类的，而不是属于某个对象。静态成员函数可以被该类的所有对象直接访问；静态成员函数本身只能访问静态成员，不可以访问非静态成员。</p><h2 id="四、常见面试题–为什么static变量值只初始化一次？"><a href="#四、常见面试题–为什么static变量值只初始化一次？" class="headerlink" title="四、常见面试题–为什么static变量值只初始化一次？"></a>四、常见面试题–为什么static变量值只初始化一次？</h2><p>对于所有的对象（不仅仅是静态对象），初始化都只有一次，初始化后，一直都没有被销毁&#x2F;释放，都会保存在内存区域中，所以不会再次初始化。存放在静态区的变量的生命周期与整个程序“同生死、共存亡”，所以它只需初始化一次。而auto变量，即自动变量，由于它存放在栈区，一旦函数调用结束，就会立刻被销毁。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> static </tag>
            
            <tag> C </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深拷贝和浅拷贝</title>
      <link href="/2022/11/11/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2022/11/11/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Team</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;默认函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Team</span>(<span class="type">int</span> a,<span class="type">int</span> b) 含参的构造函数</span><br><span class="line">&#123;</span><br><span class="line">m_A = a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Team</span>(<span class="type">const</span> Team &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;复制函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Team</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> m_A;</span><br></pre></td></tr></table></figure><p>如上面的代码。当我们在调用一个有参的构造函数声明变量  c1 并对其赋值时，我们可以通过重新使用该类声明一个新的变量 c2 ，在赋值的 ( ) 中，将已经赋值过的变量 c1 填入，即 c2(c1)。通过这样的方式 ，我们可以得到一个赋值好的 c2 变量。其中 c2 中的赋值和 c1 是相同的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Team c1(18);//含参的构造函数</span><br><span class="line">cout &lt;&lt; c1 &lt;&lt; endl;</span><br><span class="line">Team c2(c1);</span><br><span class="line">cout &lt;&lt; c2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>以上，我们是通过编译器自动生成了一次对有参函数变量的浅拷贝。</p><p>但是，有时候我们会遇到一些问题。</p><hr><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>首先要知道，堆区：由<strong>程序员</strong>分配释放，若程序员不释放，程序结束后由操作系统回收（运行期间你不管，它就不释放。运行结束就给他回收掉）</p><p>在C++中主要利用<strong>new</strong>在堆区开辟内存</p><p>回到刚刚的代码。可以看到，在Team这个类当中，只有一组参数，那就是 int m_A；m_A是整形变量。那么如果我们的参数中含有指针变量呢？如果含有指针变量，我们的函数还可以按照刚刚浅拷贝那样，由编译器即可自动完成拷贝吗？</p><p>实际上是行不通的。我们需要从浅拷贝的机制来分析。</p><p>在编译器中简单的套用有参变量去传递参数的值的时候(浅拷贝)，实质上就是一种值的传递。而当我们类中的参数含有指针变量，且指针的变量是在堆区开辟的空间，且我们选择手动在最后类的析构函数中释放这段开辟的空间的时候，编译器就会报错。这是为什么？</p><p>首先这也是一种值的传递没有错，但是这个值的传递是对于指针变量来说的，对于普通变量，值的传递就是变量中存储的值的传递。但指针就比较特殊了，指针中存储的“值”，实际上就是地址。这个地址中也存储着值。而这个地址中所存储的值，才是我们需要拷贝，需要传递的值。*(其实说到底还是指针的那些概念)</p><p>所以很明显，问题出在了析构那里。正因为我们选择了在析构函数中手动的释放堆区开辟的空间。所以我们进行了两次析构函数的调用，但其实早在第一次的时候，由于堆区的空间被释放，类中的指针成员所指向的地址和地址里的内容就已经被释放了。那么我们在第二次拷贝参数的时候，就会遇到<strong>堆区的内存被重复释放</strong>这种情况。一旦出现这种情况，编译器会判定为非法操作，自然也就报错了。那么应该如何处理呢？</p><p>以上的拷贝操作实际上是由编译器自动完成的，为了防止堆区的空间被重复释放，我们需要自己定义一个拷贝构造函数就可以解决。</p><p>首先，我们需要在堆区重新申请一块儿内存。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Team</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Team</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;默认函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Team</span>(<span class="type">int</span> a,<span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">m_A = a;</span><br><span class="line">p = <span class="keyword">new</span> <span class="built_in">int</span>(b);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Team</span>(<span class="type">const</span> Team &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;复制函数&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译器默认的实现方式(浅拷贝)</span></span><br><span class="line"><span class="comment">//m_A = a.m_A;</span></span><br><span class="line"><span class="comment">//p = a.p;</span></span><br><span class="line"></span><br><span class="line">        p = <span class="keyword">new</span> <span class="built_in">int</span>(*a.p);<span class="comment">//在堆区重新申请一块儿内存(深拷贝)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Team</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Team <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">160</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; *c1.p &lt;&lt; endl;</span><br><span class="line"><span class="function">Team <span class="title">c2</span><span class="params">(c1)</span></span>;</span><br><span class="line">cout &lt;&lt; *c2.p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 深拷贝 </tag>
            
            <tag> 浅拷贝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建</title>
      <link href="/2022/10/22/hexo%20%E6%90%AD%E5%BB%BA/"/>
      <url>/2022/10/22/hexo%20%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>—#安装git<br>git工具在外网直接下载非常慢，需要在镜像环境中下载<br>如果电脑上有360，可以通过360的软件软件安装管家搜索git，可直接下载</p><p>—#安装Nodejs<br>node -v#查看node版本<br>npm -v#查看npm版本<br>npm install -g cnpm –registry&#x3D;<a href="http://registry.npm.taobao.org/">http://registry.npm.taobao.org</a>#安装淘宝的cnpm 管理器<br>cnpm -v#查看cnpm版本<br>cnpm install -g hexo-cli    #安装hexo框架<br>hexo -v#查看hexo版本<br>mkdir blog#创建blog目录<br>cd blog #进入blog目录<br>sudo hexo init #生成博客 初始化博客<br>hexo s#启动本地博客服务<br><a href="http://localhost:4000/">http://localhost:4000/</a>#本地访问地址<br>hexo n “我的第一篇文章” #创建新的文章<br>#返回blog目录<br>hexo clean #清理<br>hexo g #生成<br>#Github创建一个新的仓库 YourGithubName.github.io</p><h2 id="cnpm-install-–save-hexo-deployer-git-在blog目录下安装git部署插件"><a href="#cnpm-install-–save-hexo-deployer-git-在blog目录下安装git部署插件" class="headerlink" title="cnpm install –save hexo-deployer-git #在blog目录下安装git部署插件"></a>cnpm install –save hexo-deployer-git #在blog目录下安装git部署插件</h2><h2 id="配置-config-yml"><a href="#配置-config-yml" class="headerlink" title="#配置_config.yml "></a>#配置_config.yml </h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:<span class="comment">//hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.这里需要注意在Windows环境下type后边有一个&#x27;&#x27;符号，需要把git写在&#x27;&#x27;里</span></span><br><span class="line"><span class="comment">    2.type:和repo:后边都需要加一个空格  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">type: git </span><br><span class="line">repo: https:<span class="comment">//benwang717.github.io</span></span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><hr><p>hexo d#部署到Github仓库里<br>&#x2F;*<br>到这里基本上就已经部署完成了，有几个需要注意的点：<br>1.在最初安装好git之后，Windows环境下 记得在 hexo d 之前敲<br>    git config –global user.email “xxx” 设置一个你自己的邮箱<br>    git config –global user.name “xxx”  设置你的昵称</p><p>2.在完成上述步骤之后，如果执行 hexo d 依然有错误</p><p>类似于”OpenSSL SSL_read: Connection was reset, errno 10054”这样的错误<br>可以通过 解除SSL认证 的方式尝试解决 具体的方法如下：<br>在当前文件位置下通过 Git Bash 中输入以下命令：<br>git config –global http.sslVerify “false” </p><p>更多问题可参考”<a href="https://blog.csdn.net/m0_51269961/article/details/123709195">https://blog.csdn.net/m0_51269961/article/details/123709195</a>“<br>*&#x2F;<br><a href="https://benwang717.github.io/">https://benwang717.github.io</a> #访问这个地址可以查看博客</p><p> git clone <a href="https://benwang717.github.io/">https://benwang717.github.io</a> themes&#x2F;yilia  #下载yilia主题到本地</p><p>#修改hexo根目录下的 _config.yml 文件 ： theme: yilia</p><p>hexo c#清理一下<br>hexo g#生成<br>hexo d#部署到远程Github仓库</p><p>或：</p><p>hexo c#清理一下<br>hexo d -g #部署+生成</p><p><a href="https://benwang717.github.io/">https://benwang717.github.io/</a>  #查看博客</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
