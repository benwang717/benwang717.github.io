<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Qt套接字通信</title>
      <link href="/2023/11/01/Qt%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E4%BF%A1/"/>
      <url>/2023/11/01/Qt%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<p>*每次用到套接字的时候都会需要查一查必要的逻辑流程, 方便速查在这里巩固总结一下</p><p>首先是模块引入:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.pro文件中引入网络模块</span></span><br><span class="line">QT += network</span><br></pre></td></tr></table></figure><p>接下来通过client和server两个方面介绍功能:</p><p>首先是client端</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTcpSocket&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在client端项目的头文件中声明套接字对象</span></span><br><span class="line">QTcpSocket* clientSocket = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"><span class="comment">//首先在堆区开辟地址(本篇只写涉及到的所有业务流程, 怎么分配这些逻辑要根据项目实际需求)</span></span><br><span class="line">clientSocket = <span class="keyword">new</span> <span class="built_in">QTcpSocket</span>(<span class="keyword">this</span>);</span><br><span class="line">tcpSocket-&gt;<span class="built_in">setSocketOption</span>(QAbstractSocket::LowDelayOption,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//创建了一个新的QTcpSocket对象，并设置其延迟选项为0。表示我们希望尽可能少的延迟，数据将被尽可能快地发送</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解下来再连接server端之前要先判断当前的连接状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前是否已连接，连接了就断开</span></span><br><span class="line"><span class="keyword">if</span>(client-&gt;<span class="built_in">state</span>()==QAbstractSocket::ConnectedState)&#123;</span><br><span class="line"><span class="comment">//如果使用disconnectFromHost()不会重置套接字，isValid还是会为true</span></span><br><span class="line">client-&gt;<span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(client-&gt;<span class="built_in">state</span>()==QAbstractSocket::UnconnectedState)&#123;</span><br><span class="line"><span class="comment">//从界面上读取ip和端口</span></span><br><span class="line"><span class="type">const</span> QHostAddress address=<span class="built_in">QHostAddress</span>(ui-&gt;editAddress-&gt;<span class="built_in">text</span>());</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> port=ui-&gt;editPort-&gt;<span class="built_in">text</span>().<span class="built_in">toUShort</span>();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">client-&gt;<span class="built_in">connectToHost</span>(address,port);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断连接是否成功，连接成功后进行提示并将按钮设置为断开</span></span><br><span class="line">    <span class="keyword">if</span>(!client-&gt;<span class="built_in">waitForConnected</span>(<span class="number">3000</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//提示连接超时</span></span><br><span class="line">        QDBG <span class="string">&quot;connect failed!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//TCP连接成功</span></span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Connected!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    QDBG <span class="string">&quot;It is not ConnectedState or UnconnectedState&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在需要主动断开连接的时候需要把以下操作封装在一个函数中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpDisconnect</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//断开与服务器的连接</span></span><br><span class="line">    client-&gt;<span class="built_in">disconnectFromHost</span>();</span><br><span class="line">    <span class="comment">//关闭套接字</span></span><br><span class="line">    client-&gt;<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//需要通过信号检查服务器连接成功与否</span></span><br><span class="line"><span class="built_in">connect</span>(client,&amp;QTcpSocket::connected,[=]()&#123;</span><br><span class="line">    <span class="comment">//成功连接时触发信号</span></span><br><span class="line">    QDBG <span class="string">&quot;TCP conncect!&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">connect</span>(client,&amp;QTcpSocket::disconnected,[=]()&#123;</span><br><span class="line"><span class="comment">//TCP断开连接</span></span><br><span class="line">    QDBG <span class="string">&quot;TCP disconncect!&quot;</span>;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>server端</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTcpServer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTcpSocket&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//server用于监听端口，获取新的tcp连接的描述符</span></span><br><span class="line">QTcpServer* server = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Server对象</span></span><br><span class="line">server = <span class="keyword">new</span> <span class="built_in">QTcpServer</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前是否已开启，是则close，否则listen</span></span><br><span class="line"><span class="keyword">if</span>(server-&gt;<span class="built_in">isListening</span>())&#123;</span><br><span class="line">    <span class="comment">//server-&gt;close();</span></span><br><span class="line">    <span class="built_in">closeServer</span>();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//从界面上读取ip和端口</span></span><br><span class="line">    <span class="comment">//可以使用 QHostAddress::Any 监听所有地址的对应端口</span></span><br><span class="line">    <span class="type">const</span> QString address_text=ui-&gt;editAddress-&gt;<span class="built_in">text</span>();</span><br><span class="line">    <span class="type">const</span> QHostAddress address=(address_text==<span class="string">&quot;Any&quot;</span>)?QHostAddress::Any:<span class="built_in">QHostAddress</span>(address_text);</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> port=ui-&gt;editPort-&gt;<span class="built_in">text</span>().<span class="built_in">toUShort</span>();</span><br><span class="line">    <span class="comment">//开始监听，并判断是否成功</span></span><br><span class="line">    <span class="keyword">if</span>(server-&gt;<span class="built_in">listen</span>(address,port))&#123;</span><br><span class="line">        <span class="comment">//连接成功</span></span><br><span class="line">        QDBG <span class="string">&quot;连接成功&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听到新的客户端连接请求</span></span><br><span class="line">    <span class="built_in">connect</span>(server,&amp;QTcpServer::newConnection,<span class="keyword">this</span>,[<span class="keyword">this</span>]&#123;</span><br><span class="line">        <span class="comment">//如果有新的连接就取出</span></span><br><span class="line">        <span class="keyword">while</span>(server-&gt;<span class="built_in">hasPendingConnections</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//nextPendingConnection返回下一个挂起的连接作为已连接的QTcpSocket对象</span></span><br><span class="line">            <span class="comment">//套接字是作为服务器的子级创建的，这意味着销毁QTcpServer对象时会自动删除该套接字。</span></span><br><span class="line">            <span class="comment">//最好在完成处理后显式删除该对象，以避免浪费内存。</span></span><br><span class="line">            <span class="comment">//返回的QTcpSocket对象不能从另一个线程使用，如有需要可重写incomingConnection().</span></span><br><span class="line">            QTcpSocket *socket=server-&gt;<span class="built_in">nextPendingConnection</span>();</span><br><span class="line">            clientList.<span class="built_in">append</span>(socket);</span><br><span class="line">            ui-&gt;textRecv-&gt;<span class="built_in">append</span>(<span class="built_in">QString</span>(<span class="string">&quot;[%1:%2] Soket Connected&quot;</span>)</span><br><span class="line">                                 .<span class="built_in">arg</span>(socket-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toString</span>())</span><br><span class="line">                                 .<span class="built_in">arg</span>(socket-&gt;<span class="built_in">peerPort</span>()));</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//关联相关操作的信号槽</span></span><br><span class="line">            <span class="comment">//收到数据，触发readyRead</span></span><br><span class="line">            <span class="built_in">connect</span>(socket,&amp;QTcpSocket::readyRead,[<span class="keyword">this</span>,socket]&#123;</span><br><span class="line">                <span class="comment">//没有可读的数据就返回</span></span><br><span class="line">                <span class="keyword">if</span>(socket-&gt;<span class="built_in">bytesAvailable</span>()&lt;=<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">//注意收发两端文本要使用对应的编解码</span></span><br><span class="line">                <span class="type">const</span> QString recv_text=QString::<span class="built_in">fromUtf8</span>(socket-&gt;<span class="built_in">readAll</span>());</span><br><span class="line">                ui-&gt;textRecv-&gt;<span class="built_in">append</span>(<span class="built_in">QString</span>(<span class="string">&quot;[%1:%2]&quot;</span>)</span><br><span class="line">                                     .<span class="built_in">arg</span>(socket-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toString</span>())</span><br><span class="line">                                     .<span class="built_in">arg</span>(socket-&gt;<span class="built_in">peerPort</span>()));</span><br><span class="line">                ui-&gt;textRecv-&gt;<span class="built_in">append</span>(recv_text);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//server向client发送内容</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;btnSend,&amp;QPushButton::clicked,[<span class="keyword">this</span>]&#123;</span><br><span class="line">        <span class="comment">//判断是否开启了server</span></span><br><span class="line">        <span class="keyword">if</span>(!server-&gt;<span class="built_in">isListening</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//将发送区文本发送给客户端</span></span><br><span class="line">        <span class="type">const</span> QByteArray send_data=ui-&gt;textSend-&gt;<span class="built_in">toPlainText</span>().<span class="built_in">toUtf8</span>();</span><br><span class="line">        <span class="comment">//数据为空就返回</span></span><br><span class="line">        <span class="keyword">if</span>(send_data.<span class="built_in">isEmpty</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(QTcpSocket *socket:clientList)</span><br><span class="line">        &#123;</span><br><span class="line">            socket-&gt;<span class="built_in">write</span>(send_data);</span><br><span class="line">            <span class="comment">//socket-&gt;waitForBytesWritten();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//server的错误信息</span></span><br><span class="line">    <span class="comment">//如果发生错误，则serverError()返回错误的类型，</span></span><br><span class="line">    <span class="comment">//并且可以调用errorString()以获取对所发生事件的易于理解的描述</span></span><br><span class="line">    <span class="built_in">connect</span>(server,&amp;QTcpServer::acceptError,[<span class="keyword">this</span>](QAbstractSocket::SocketError)&#123;</span><br><span class="line">        ui-&gt;textRecv-&gt;<span class="built_in">append</span>(<span class="string">&quot;Server Error:&quot;</span>+server-&gt;<span class="built_in">errorString</span>());</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="type">void</span> Widget::<span class="built_in">closeServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//停止服务</span></span><br><span class="line">    server-&gt;<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">for</span>(QTcpSocket * socket:clientList)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//断开与客户端的连接</span></span><br><span class="line">        socket-&gt;<span class="built_in">disconnectFromHost</span>();</span><br><span class="line">        <span class="keyword">if</span>(socket-&gt;<span class="built_in">state</span>()!=QAbstractSocket::UnconnectedState)&#123;</span><br><span class="line">            socket-&gt;<span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> QTcpSocket </tag>
            
            <tag> QTcpServer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简化qDebug()输出方式</title>
      <link href="/2023/10/31/%E7%AE%80%E5%8C%96qDebug()%E8%BE%93%E5%87%BA%E6%96%B9%E5%BC%8F/"/>
      <url>/2023/10/31/%E7%AE%80%E5%8C%96qDebug()%E8%BE%93%E5%87%BA%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>Qt总在测试输出的时候在声明<QDebug>之后就可以通过qDebug()&lt;&lt;的方式输出, 方便测试.</p><p>在复杂的项目中涉及到输出的内容较多, 为了方便找到输出的对应内容, 这里需要简化qDebug()的写法, 方式很简单:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在相关的头文件中添加一下语句</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QDBG qDebug()&lt;&lt; __FILE__ &lt;&lt; __FUNCTION__ &lt;&lt; __LINE__ &lt;&lt;</span></span><br><span class="line"><span class="comment">//这里需要注意file表示文件位置, function表示所在函数, line表示代码所在的行数</span></span><br></pre></td></tr></table></figure><p>宏定义之后, 如果要输出就可以这样写</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QDBG <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果宏定义最后的 &lt;&lt; 符号没有添加, 则应该这样写</span></span><br><span class="line"><span class="comment">//QDBG &lt;&lt; &quot;Hello World!&quot;;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyVISA库</title>
      <link href="/2023/10/24/PyVisa%E5%BA%93/"/>
      <url>/2023/10/24/PyVisa%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>VISA (Virtual Instrument Software Architecture) 是一个用于访问测量仪器和控制计算机之间的接口标准，用于实现仪器之间的通信和控制。VISA提供了一组标准API函数，可以实现多种通信协议和连接方式的仪器控制。VISA相比于VXI11更加灵活，支持多种接口（底层协议），比如GPIB，RS232，USB， VXIBus等，对于仪器控制有更强大的功能, SCPI（Standard Commands for Programmable Instruments）是一种标准命令集, 这次学到的多东西比较零碎, 为了避免自己忘记, 我这边记录一下, 以便以后把整体流程捋清楚.</p><p><img src="/../images/image-20231024160238410.png" alt="image-20231024160238410"></p><p>1.首先是我目前用到了一台数据采集器, 型号是DAQ970a, 是德科技的产品. 目前根据官网的链接, 把仪器对应的软件下载安装后, 通过官方开发的软件对远程控制采集器的基本使用方法已经了解. 现在的需求是需要根据具体需求对远程控制仪器进行二次开发. 查阅了各种相关的文档之后, 发现这种二次开发控制采集器属于GPIB或者说是机器编程的范畴(目前的认知还有待提高).</p><p>2.然后在基本明确需求之后, 现在需要尝试建立通信, 这里我查阅了晚上很多文档, 发现相当一部分是用python写的, 对于很久没有用过python的我而言是有些门槛的, 但是还是本着能多学一点是一点的态度, 这边使用了pycharm写了新建python项目写的</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#这里是要给项目引入相关库的, 由于是第一次使用pycharm, 对外部库的引入也是废了一点时间</span></span><br><span class="line"><span class="comment">#这里需要把在python项目中引入外部库的流程说明一下:</span></span><br><span class="line"><span class="comment">#1.根据我们新建项目的所在路径在路径中找到&quot;python.exe&quot;这个文件, 根据这个文件所在的路径打开命令行</span></span><br><span class="line"><span class="comment">#2.win+r打开运行窗口, 输入cmd后回车</span></span><br><span class="line"><span class="comment">#3.在命令窗口中输入: &quot; &quot;刚刚保存的路径(要到/python.exe)&quot; +  -m pip install visa -i https://pypi.tuna.tsinghua.edu.cn/simple &quot;类似于以下</span></span><br><span class="line"><span class="comment">#C:\Users&gt;D:\BaiduNetdiskDownload\myProjects\more\pyProjects\pProject07\venv\Scripts\python.exe -m pip install visa -i https://pypi.tuna.tsinghua.edu.cn/simple</span></span><br><span class="line"><span class="comment">#需要注意的是python项目中的环境需要配置在其项目目录中</span></span><br><span class="line"><span class="comment">#4.安装完成之后就可以在python项目中引入库了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>  pyvisa</span><br><span class="line"></span><br><span class="line">rm = pyvisa.ResourceManager()</span><br><span class="line">t = rm.list_resources()</span><br><span class="line"><span class="built_in">print</span>(t)</span><br></pre></td></tr></table></figure><p>到此为止, 已经可以获取连接设备的设备编号了, 还在补充中</p>]]></content>
      
      
      
        <tags>
            
            <tag> pyvisa </tag>
            
            <tag> python </tag>
            
            <tag> SCPI </tag>
            
            <tag> GPIB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DAQ970A数据采集器</title>
      <link href="/2023/10/12/DAQ970A%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%99%A8/"/>
      <url>/2023/10/12/DAQ970A%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>最近项目中需要用到数据采集器, 开始也是一头雾水, 说是要用到型号DAQ970A的数据采集器, 又说要用到支持mudbusTCP协议的485十六口工业级集线器, 还说什么要把这两个东西链接在一起, 我$^@#%*!&amp;@**#%!</p><p>因为在这之前我有很久没碰过硬件相关的东西了, 在一开始是比较抗拒的, 但是事来了躲也是躲不过最终还是要面对. 通过一段时间的摸索, 对于这款数据采集器的基本使用算是摸明白了, 避免学过的东西过两天又忘掉, 这里还是写一篇笔记做预留. </p><h3 id="1-首先是设备端网络配置的相关方法"><a href="#1-首先是设备端网络配置的相关方法" class="headerlink" title="1. 首先是设备端网络配置的相关方法"></a>1. 首先是设备端网络配置的相关方法</h3><p>这里我只把我在业务中使用到的方法罗列一下, 用不到的可能我也不会 ^_^</p><p>先简单介绍一下这款设备, 顾名思义就是个 数据 采集 器</p><p>这是官网的链接 <a href="https://www.keysight.com.cn/cn/zh/products/modular/data-acquisition-daq/digital-acquisition-benchtop-system/daq970a-data-acquisition-system.html">https://www.keysight.com.cn/cn/zh/products/modular/data-acquisition-daq/digital-acquisition-benchtop-system/daq970a-data-acquisition-system.html</a></p><p>还有两本中英文pdf说明书, 资源在这里</p><p>链接：<a href="https://pan.baidu.com/s/1f0hALDg-s026CIgkYStGgg">https://pan.baidu.com/s/1f0hALDg-s026CIgkYStGgg</a><br>提取码：a04f</p><p>业务中用到的是LAN口, 使用无线的方式控制数据采集器, 首先就是配网, 首先我们自己的PC要连接到一个路由器, 确保在同一个网络下, 之后网线分别连接路由器和数据采集器的LAN口, 以下是数据采集的LAN口示意图</p><p><img src="/../images/image-20231012091225787.png" alt="image-20231012091225787"></p><p>连接之后可以看到LAN处的灯闪烁, 这个时候我们来到设备的前面查看网络配置信息</p><p>在主界面首先点击主页确保复位, 然后点击UserSetting</p><p><img src="/../images/image-20231012091826710.png" alt="image-20231012091826710"></p><p>然后选择I&#x2F;O</p><p><img src="/../images/image-20231012091857706.png" alt="image-20231012091857706"></p><p>可以看到如下界面, 如果我们的LAN口有链接, 那么可以看到LAN Off&#x2F;On 所处的状态应该是On, 但如果显示状态为Off, 我们需要关闭仪器重启查看状态是否更新.  像图示中的可以看到状态已经是On, 那么接下来点击LAN Settings</p><p><img src="/../images/image-20231012092418623.png" alt="image-20231012092418623"></p><p>点击LAN Settings, 可以看到相应的网络配置信息, 这里我们需要记住这些信息, 在PC连接的时候会用到, 最后点击主页home, 设备端的操作就完成了</p><p><img src="/../images/image-20231012092606471.png" alt="image-20231012092606471"></p><p>设备端的网络配置说简单一点就是, 插上网线, 检查网络信息, 就这么多</p><h3 id="2-然后是PC端连接到设备端的操作方法"><a href="#2-然后是PC端连接到设备端的操作方法" class="headerlink" title="2. 然后是PC端连接到设备端的操作方法"></a>2. 然后是PC端连接到设备端的操作方法</h3><p>这里需要用的这个公司开发的产品相关软件 <u>BenchVue 数据采集控制和分析应用软件</u></p><p>这里是他们公司的链接: <a href="https://www.keysight.com.cn/cn/zh/lib/software-detail/computer-software/benchvue-data-acquisition-control-and-analysis-download-2815595.html">https://www.keysight.com.cn/cn/zh/lib/software-detail/computer-software/benchvue-data-acquisition-control-and-analysis-download-2815595.html</a></p><p>下载安装之后, 在配置网络的时候, 我们需要依次操作两个软件Keysight Connection Expert 和 Keysight BenchVue</p><p>首先打开界面, 参考下图, 点击add选择LAN instrument 或者 点击Instrument 添加设备, </p><p><img src="/../images/image-20231012094048711.png" alt="image-20231012094048711"></p><p>看一看到以下界面, 这里Select from List 是从自动查询到的设备中添加, Enter Address 是手动通过ip添加设备, 可以看到自动未查询到设备, 所以我们选择手动添加设备.</p><p><img src="/../images/image-20231012094318636.png" alt="image-20231012094318636"></p><p>如下图所示,  在Enter Address界面中, 我们需要再Hostname or IP Address: 中输入ip地址, 这里就需要输入我们上一步在设备端 I&#x2F;O 界面下网络设置相关界面中的ip地址, 输入完成后, 其他的配置信息默认即可, 点击ok</p><p><img src="/../images/image-20231012094643779.png" alt="image-20231012094643779"></p><p>如下图所示, 这个时候我们的设备就添加成功了, 在添加完成之后我们需要测试一下设备的连接状态, 点击 Interactive IO</p><p><img src="/../images/image-20231012094923639.png" alt="image-20231012094923639"></p><p>可以看到界面中存在一个默认命令 *IDN?  这个命令是控制设备返回设备产品序号的, 如果成功返回产品序号, 说明设备连接成功, 点击 Send &amp; Read 发送命令</p><p><img src="/../images/image-20231012095125305.png" alt="image-20231012095125305"></p><p>返回成功, 如下图, 可以看到设备已经配置完成</p><p><img src="/../images/image-20231012095241818.png" alt="image-20231012095241818"></p><p>到这里网络配置就已经完成了, 接下来是数据采集</p><h3 id="3-数据采集"><a href="#3-数据采集" class="headerlink" title="3.数据采集"></a>3.数据采集</h3><p>数据的采集的相关配置有两种方式, 一种是通过设备直接设置, 另外一种是通过已经配置好网络连接到设备的PC软件控制</p><p>第一种方式是需要对设备拍照, 每一步都要拍照, 一是麻烦, 二是设备是公司的, 这样搞还是会有摸鱼的嫌疑这里我会找到他们官方的一个设备端的数据采集的配置视频,链接在这里: <a href="https://www.bilibili.com/video/BV1PV4y1P7Dy/">https://www.bilibili.com/video/BV1PV4y1P7Dy/</a></p><p>第二种方式我是会操作但是有更好的讲解的视频链接,这里我也不再描述了, 请参考视频链接: <a href="https://www.bilibili.com/video/BV1mk4y1T7oz">https://www.bilibili.com/video/BV1mk4y1T7oz</a></p><p>*还是先吐槽一下这个是德科技, 一家国产公司, 做的产品甚至没有设置中文版本, 连发货来的说明书都是英文的, 怎么说呢, 国产厂家能整理出英文说明书, 你说做不出中文版本的设备那是不可能的. 受迫于市场的传统认知, 只能做出无奈的”伪装”, 包装成看起来好像是”洋产品”, 可能也更让很多国内的采购方认你这个东西, 产业升级任重而道远只能说, 国人对国产产品的认知和和偏见在早些年是客观事实, 但是近些年随着国产产品迭代升级, 相当一部分的中低端产品性价比要样产品做的要更好. 怎么说群体认知是一个漫长的过程, 产业相关方有争夺高端市场的决心和认知学习的态度, 相信用质量说话, 国产产品再未来会赢得话语权.</p><p>*数据采集器的使用在摸明白之后还算不是很麻烦的, 这段时间对modbus的协议的学习占用了比较多的时间, 包括数据发送端命令的格式, 数据接收端对数据的校验, 还有连接的状态, 最后还封装功能的时候还涉及到了多线程处理. 这写东西占用的比较多的时间, 以后有机会我可能会更新相关的笔记, 但是我看modbus相关的协议文章网上有很多了, 而且很多文章讲的都非常好了, 可能我会只写一下具体的知识点, 或一些具体的功能细节.</p>]]></content>
      
      
      
        <tags>
            
            <tag> DAQ970A </tag>
            
            <tag> 数据采集器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QML Canvas绘制一个简单的仪表盘</title>
      <link href="/2023/09/19/QML%20Canvas%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BB%AA%E8%A1%A8%E7%9B%98/"/>
      <url>/2023/09/19/QML%20Canvas%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BB%AA%E8%A1%A8%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<p>模仿游戏开始了, 今天要绘制一个仪表盘, 原文链接放下面了, 这里感谢一下作者, 我要争取把这个作者的所有笔记学习消化一遍.</p><p><a href="https://gongjianbo1992.blog.csdn.net/article/details/104453526">https://gongjianbo1992.blog.csdn.net/article/details/104453526</a></p><p>使用Qt Design Studio新建项目, 这里要在默认项目中新添加一个qml文件命名为<em>MyDial.qml</em>, 在app.qml中, 把原文中main.qml内容放置在里面, 然后确认无误后把程序跑起来, 可以看到仪表盘绘制完成. 下面就是开始分析代码结构, 首先是<em>MyDial.qml</em>中的部分, 这里直接上代码:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MyDial.qml</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">QtQuick</span> <span class="number">2.12</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">QtQuick</span>.<span class="property">Controls</span> <span class="number">2.12</span></span><br><span class="line"> </span><br><span class="line"><span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="attr">id</span>: control</span><br><span class="line"> </span><br><span class="line">    property int <span class="attr">lineWidth</span>: <span class="number">3</span></span><br><span class="line">    property int <span class="attr">fontPx</span>: <span class="number">16</span></span><br><span class="line">    property color <span class="attr">themeColor</span>: <span class="string">&quot;#00C1DE&quot;</span></span><br><span class="line"> </span><br><span class="line">    property int <span class="attr">padding</span>: <span class="number">20</span></span><br><span class="line">    property int <span class="attr">radius</span>: (width/<span class="number">2</span>&lt;height)?(width/<span class="number">2</span>-<span class="number">2</span>*padding):(height-<span class="number">2</span>*padding)</span><br><span class="line">    property int <span class="attr">half</span>: control.<span class="property">radius</span>+control.<span class="property">padding</span></span><br><span class="line"> </span><br><span class="line">    property double <span class="attr">minValue</span>: <span class="number">0</span></span><br><span class="line">    property double <span class="attr">maxValue</span>: <span class="number">100</span></span><br><span class="line">    property double <span class="attr">currentValue</span>: <span class="number">0</span></span><br><span class="line">    property int <span class="attr">stepSize</span>: <span class="number">6</span></span><br><span class="line">    property double <span class="attr">stepValue</span>: (control.<span class="property">maxValue</span>-control.<span class="property">minValue</span>)/(stepSize-<span class="number">1</span>)</span><br><span class="line">    property double <span class="attr">stepAngle</span>: <span class="title class_">Math</span>.<span class="property">PI</span>/(control.<span class="property">stepSize</span>-<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="attr">onCurrentValueChanged</span>: &#123;</span><br><span class="line">        canvas.<span class="title function_">requestPaint</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//背景刻度</span></span><br><span class="line">    <span class="title class_">Canvas</span>&#123;</span><br><span class="line">        <span class="attr">id</span>: canvas</span><br><span class="line">        anchors.<span class="property">bottom</span>: parent.<span class="property">bottom</span></span><br><span class="line">        anchors.<span class="property">horizontalCenter</span>: parent.<span class="property">horizontalCenter</span></span><br><span class="line"> </span><br><span class="line">        <span class="attr">width</span>: control.<span class="property">half</span>*<span class="number">2</span></span><br><span class="line">        <span class="comment">//底部也有一个padding</span></span><br><span class="line">        <span class="attr">height</span>: control.<span class="property">half</span>+control.<span class="property">padding</span></span><br><span class="line"> </span><br><span class="line">        <span class="attr">onPaint</span>: &#123;</span><br><span class="line">            <span class="keyword">let</span> ctx=<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line"><span class="comment">//这里存在一个知识点, let 是 JavaScript 中的一个关键字，用于声明一个块作用域的局部变量。</span></span><br><span class="line"><span class="comment">//在 JavaScript 中，以前用于声明变量的关键字是 var，但它存在一些作用域的问题。为解决这些问题，并引入块级作用域的概念，ES6 (ECMAScript 2015) 引入了 let 和 const 这两个新的变量声明关键字。</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">//let 声明的变量具有以下特点：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//块级作用域：let 声明的变量仅在当前代码块内有效，不会受外部作用域（如函数作用域）的影响。</span></span><br><span class="line"><span class="comment">//不进行变量提升：let 声明的变量不存在变量提升，即必须先声明后使用，否则会报错。</span></span><br><span class="line"><span class="comment">//不允许重复声明：在同一作用域内使用 let 声明同名的变量会导致语法错误。</span></span><br><span class="line"><span class="comment">//可以更新值：let 声明的变量可以进行赋值操作，可以随时更新变量的值。</span></span><br><span class="line"><span class="comment">//在这段代码中，let 用于声明一个局部变量 ctx，它的作用范围仅限于当前的代码块内。这样可以确保 ctx 变量只在 onPaint 函数内部有效，不会影响到其他的代码。</span></span><br><span class="line"><span class="comment">//详解见菜鸟教程:https://www.runoob.com/w3cnote/es6-let-const.html</span></span><br><span class="line">            ctx.<span class="property">lineWidth</span>=control.<span class="property">lineWidth</span>;</span><br><span class="line">            ctx.<span class="property">font</span>=<span class="title class_">String</span>(control.<span class="property">fontPx</span>)+<span class="string">&quot;px SimHei bold&quot;</span></span><br><span class="line">            ctx.<span class="property">fillStyle</span>=control.<span class="property">themeColor</span>;</span><br><span class="line">            ctx.<span class="property">strokeStyle</span>=control.<span class="property">themeColor</span>;</span><br><span class="line">            ctx.<span class="property">lineCap</span>=<span class="string">&quot;round&quot;</span>;</span><br><span class="line">            ctx.<span class="title function_">clearRect</span>(<span class="number">0</span>,<span class="number">0</span>,width,height);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//原点平移</span></span><br><span class="line">            ctx.<span class="title function_">save</span>();</span><br><span class="line">            ctx.<span class="title function_">translate</span>(control.<span class="property">half</span>,control.<span class="property">half</span>)</span><br><span class="line">            ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">            <span class="comment">//radius-linewidth</span></span><br><span class="line">            <span class="comment">//x,y,r,起始角右侧，终止角顺时针旋转</span></span><br><span class="line">            ctx.<span class="title function_">arc</span>(<span class="number">0</span>,<span class="number">0</span>,control.<span class="property">radius</span>,<span class="title class_">Math</span>.<span class="property">PI</span>,<span class="number">2</span>*<span class="title class_">Math</span>.<span class="property">PI</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//绘制刻度</span></span><br><span class="line">            ctx.<span class="title function_">save</span>();</span><br><span class="line">            ctx.<span class="title function_">rotate</span>(<span class="title class_">Math</span>.<span class="property">PI</span>*<span class="number">1.5</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i=control.<span class="property">minValue</span>;i&lt;control.<span class="property">maxValue</span>+<span class="number">1</span>;i+=control.<span class="property">stepValue</span>)&#123;</span><br><span class="line">                ctx.<span class="title function_">moveTo</span>(<span class="number">0</span>,-control.<span class="property">radius</span>+<span class="number">10</span>);</span><br><span class="line">                ctx.<span class="title function_">lineTo</span>(<span class="number">0</span>,-control.<span class="property">radius</span>);</span><br><span class="line">                ctx.<span class="title function_">fillText</span>(<span class="title class_">String</span>(i),-<span class="number">10</span>,-control.<span class="property">radius</span>+<span class="number">10</span>+control.<span class="property">fontPx</span>)</span><br><span class="line"> </span><br><span class="line">                ctx.<span class="title function_">rotate</span>(control.<span class="property">stepAngle</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ctx.<span class="title function_">stroke</span>();</span><br><span class="line">            ctx.<span class="title function_">restore</span>();</span><br><span class="line"> </span><br><span class="line">            ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">            <span class="comment">//绘制指针</span></span><br><span class="line">            ctx.<span class="title function_">arc</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">2</span>*<span class="title class_">Math</span>.<span class="property">PI</span>);</span><br><span class="line">            ctx.<span class="title function_">rotate</span>(<span class="title class_">Math</span>.<span class="property">PI</span>*<span class="number">1.5</span>+control.<span class="property">currentValue</span>*<span class="title class_">Math</span>.<span class="property">PI</span>/(control.<span class="property">maxValue</span>-control.<span class="property">minValue</span>));</span><br><span class="line">            ctx.<span class="title function_">moveTo</span>(<span class="number">0</span>,-control.<span class="property">radius</span>+<span class="number">15</span>+control.<span class="property">fontPx</span>);</span><br><span class="line">            ctx.<span class="title function_">lineTo</span>(<span class="number">0</span>,-<span class="number">5</span>);</span><br><span class="line">            ctx.<span class="title function_">stroke</span>();</span><br><span class="line">            ctx.<span class="title function_">restore</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">setValue</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(value&lt;control.<span class="property">minValue</span>||value&gt;control.<span class="property">maxValue</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        control.<span class="property">currentValue</span>=value;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//这个参数value为什么没有定义类型?</span></span><br><span class="line"><span class="comment">//在 JavaScript 中，函数参数的类型是动态的，也就是说，你不需要显式地指定参数的类型。JavaScript 是一门弱类型语言，它使用动态类型系统，允许变量在运行时可以被赋予不同的数据类型。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在这段代码中，函数 `setValue` 的参数 `value` 并没有显式指定类型。这是 JavaScript 的特性之一，函数参数的类型会根据传入的实际值来确定。因此，你可以将任何类型的值传递给 `value`，例如数字、字符串、对象等。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在函数体内部，代码会使用传入的 `value` 进行范围检查和赋值操作，这并不依赖于参数的类型。这是 JavaScript 的灵活性之一，允许你在函数内部根据实际需要处理不同类型的值，而不需要在函数定义时指定具体的类型。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需要注意的是，在代码中没有对参数 `value` 的类型进行处理和验证，因此你需要在函数调用时自行确保传入的参数符合预期的类型和范围。</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是App.qml</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">QtQuick</span> <span class="number">6.2</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">QtQuick</span>.<span class="property">Window</span> <span class="number">6.2</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">UntitledProject1</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Window</span> &#123;</span><br><span class="line">    <span class="attr">id</span>: root</span><br><span class="line">    <span class="attr">visible</span>: <span class="literal">true</span></span><br><span class="line">    <span class="attr">width</span>: <span class="number">640</span></span><br><span class="line">    <span class="attr">height</span>: <span class="number">480</span></span><br><span class="line">    <span class="attr">title</span>: <span class="title function_">qsTr</span>(<span class="string">&quot;The Imitation Game 2023&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Column</span>&#123;</span><br><span class="line">        anchors.<span class="property">centerIn</span>: parent</span><br><span class="line">        <span class="attr">spacing</span>: <span class="number">20</span></span><br><span class="line">        <span class="comment">//spacing:调节两个相邻元素的像素距离</span></span><br><span class="line">        <span class="title class_">MyDial</span>&#123;</span><br><span class="line">            <span class="attr">id</span>: dial</span><br><span class="line">            <span class="attr">width</span>: root.<span class="property">width</span>-<span class="number">40</span></span><br><span class="line">            <span class="attr">height</span>: width/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//测试用，查看canvas范围</span></span><br><span class="line">            <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">                anchors.<span class="property">fill</span>: parent</span><br><span class="line">                <span class="attr">color</span>: <span class="string">&quot;transparent&quot;</span></span><br><span class="line">                <span class="attr">radius</span>: <span class="number">10</span></span><br><span class="line">                border.<span class="property">width</span>: <span class="number">2</span></span><br><span class="line">                border.<span class="property">color</span>: dial.<span class="property">themeColor</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title class_">Text</span>&#123;</span><br><span class="line">            anchors.<span class="property">horizontalCenter</span>: parent.<span class="property">horizontalCenter</span></span><br><span class="line">            <span class="attr">text</span>: <span class="string">&quot;当前值：&quot;</span>+<span class="title class_">String</span>(dial.<span class="property">currentValue</span>)</span><br><span class="line">            font.<span class="property">pixelSize</span>: <span class="number">20</span></span><br><span class="line">            <span class="attr">color</span>: dial.<span class="property">themeColor</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试用，点击增加值</span></span><br><span class="line">    <span class="title class_">MouseArea</span>&#123;</span><br><span class="line">        anchors.<span class="property">fill</span>: parent</span><br><span class="line">        <span class="attr">onClicked</span>:&#123;</span><br><span class="line">            <span class="comment">//dial.setValue(100);</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;bf&quot;</span>,dial.<span class="property">currentValue</span>)</span><br><span class="line">            <span class="keyword">if</span>(dial.<span class="property">currentValue</span>&lt;dial.<span class="property">maxValue</span>)&#123;</span><br><span class="line">                dial.<span class="property">currentValue</span>+=dial.<span class="property">stepValue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dial.<span class="property">currentValue</span>=dial.<span class="property">minValue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;af:&quot;</span>,dial.<span class="property">currentValue</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> QML </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识qml</title>
      <link href="/2023/09/19/%E5%88%9D%E8%AF%86qml/"/>
      <url>/2023/09/19/%E5%88%9D%E8%AF%86qml/</url>
      
        <content type="html"><![CDATA[<p>看到当下岗位技术栈要求中, 很多都需要具备qml的编程能力, 考虑到qml客观适用于当下市场中很多类似仪表盘的场景, 包括新能源车行业, 充电桩行业等… 接下来从零开始, 我会记录自己的qml的学习过程, 把学习到的知识点和每个过程中记录的笔记, 真的是学如逆水行舟, 感觉还是要不断地促使自己学点东西, 把时间利用起来集中精神去做一件事也是打发时间一种途径, 何乐而不为呢?</p><h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p>考虑到qt官方正在把qml的部分一点点独立移植到Qt Design Studio中, 以后qml开发使用Qt Design Studio会更加利好. 所以我会使用Qt Design Studio进行qml的学习.</p><p>首先使用qml新建一个空项目, 默认的新项目运行起来是覆盖全屏的, 所以为了方便调试, 需要把宽高设定为定值:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="attr">id</span>: rectangle</span><br><span class="line"><span class="comment">//    width: Constants.width</span></span><br><span class="line"><span class="comment">//    height: Constants.height</span></span><br><span class="line">    <span class="attr">width</span>: <span class="number">800</span></span><br><span class="line">    <span class="attr">height</span>: <span class="number">600</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下里是全部代码:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">QtQuick</span> <span class="number">6.2</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">QtQuick</span>.<span class="property">Controls</span> <span class="number">6.2</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">UntitledProject</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="attr">id</span>: rectangle</span><br><span class="line"><span class="comment">//    width: Constants.width</span></span><br><span class="line"><span class="comment">//    height: Constants.height</span></span><br><span class="line">    <span class="attr">width</span>: <span class="number">800</span></span><br><span class="line">    <span class="attr">height</span>: <span class="number">600</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">color</span>: <span class="title class_">Constants</span>.<span class="property">backgroundColor</span></span><br><span class="line"></span><br><span class="line">    <span class="title class_">Button</span> &#123;</span><br><span class="line">        <span class="attr">id</span>: button</span><br><span class="line">        <span class="attr">text</span>: <span class="title function_">qsTr</span>(<span class="string">&quot;Press me&quot;</span>)</span><br><span class="line">        anchors.<span class="property">verticalCenter</span>: parent.<span class="property">verticalCenter</span></span><br><span class="line">        <span class="attr">checkable</span>: <span class="literal">true</span></span><br><span class="line">        anchors.<span class="property">horizontalCenter</span>: parent.<span class="property">horizontalCenter</span></span><br><span class="line"></span><br><span class="line">        <span class="title class_">Connections</span> &#123;</span><br><span class="line">            <span class="attr">target</span>: button</span><br><span class="line">            <span class="attr">onClicked</span>: animation.<span class="title function_">start</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Text</span> &#123;</span><br><span class="line">        <span class="attr">id</span>: label</span><br><span class="line">        <span class="attr">text</span>: <span class="title function_">qsTr</span>(<span class="string">&quot;Hello UntitledProject&quot;</span>)</span><br><span class="line">        anchors.<span class="property">top</span>: button.<span class="property">bottom</span></span><br><span class="line">        font.<span class="property">family</span>: <span class="title class_">Constants</span>.<span class="property">font</span>.<span class="property">family</span></span><br><span class="line">        anchors.<span class="property">topMargin</span>: <span class="number">45</span></span><br><span class="line">        anchors.<span class="property">horizontalCenter</span>: parent.<span class="property">horizontalCenter</span></span><br><span class="line"></span><br><span class="line">        <span class="title class_">SequentialAnimation</span> &#123;</span><br><span class="line">            <span class="attr">id</span>: animation</span><br><span class="line"></span><br><span class="line">            <span class="title class_">ColorAnimation</span> &#123;</span><br><span class="line">                <span class="attr">id</span>: colorAnimation1</span><br><span class="line">                <span class="attr">target</span>: rectangle</span><br><span class="line">                <span class="attr">property</span>: <span class="string">&quot;color&quot;</span></span><br><span class="line">                <span class="attr">to</span>: <span class="string">&quot;#2294c6&quot;</span></span><br><span class="line">                <span class="attr">from</span>: <span class="title class_">Constants</span>.<span class="property">backgroundColor</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="title class_">ColorAnimation</span> &#123;</span><br><span class="line">                <span class="attr">id</span>: colorAnimation2</span><br><span class="line">                <span class="attr">target</span>: rectangle</span><br><span class="line">                <span class="attr">property</span>: <span class="string">&quot;color&quot;</span></span><br><span class="line">                <span class="attr">to</span>: <span class="title class_">Constants</span>.<span class="property">backgroundColor</span></span><br><span class="line">                <span class="attr">from</span>: <span class="string">&quot;#2294c6&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">states</span>: [</span><br><span class="line">        <span class="title class_">State</span> &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&quot;clicked&quot;</span></span><br><span class="line">            <span class="attr">when</span>: button.<span class="property">checked</span></span><br><span class="line"></span><br><span class="line">            <span class="title class_">PropertyChanges</span> &#123;</span><br><span class="line">                <span class="attr">target</span>: label</span><br><span class="line">                <span class="attr">text</span>: <span class="title function_">qsTr</span>(<span class="string">&quot;Button Checked&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上是新建项目的默认代码, 通过观察代码, 可以发现, qml的结构是块状的( 初学可以暂时先这样简单的理解 ). 块中可以包含块, 有点感觉类似于CSS那味儿. 这些块无论关系怎样, 它们都包含有一个id, 这里这个id 可以理解成C++中实例化的对象名.  除此之外还包含一些其它的基本信息, 如上图代码, 可能是位置, 宽高, 和父类的关系等. 给我的感觉基础的知识没什么复杂的逻辑在里面, 但是知识点就是多一点, 碎一点. 按部就班的按照知识点全面的学一遍应该是不太适合我, 我个人就是全面学一遍等于全面没有学. 所以我会选取一些经典的案例, 从案例中拆解知识点把, 更容易记住消化这些知识点.</p>]]></content>
      
      
      
        <tags>
            
            <tag> QML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二进制模2除法（CRC校验）</title>
      <link href="/2023/09/08/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%A8%A12%E9%99%A4%E6%B3%95/"/>
      <url>/2023/09/08/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%A8%A12%E9%99%A4%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>防止原资源文档丢失, 所以把内容留存在这里, 留作个人笔记</p><p>以下内容转载于:<a href="https://blog.csdn.net/weixin_39450145/article/details/83987836">https://blog.csdn.net/weixin_39450145/article/details/83987836</a></p><h3 id="二进制模2除法与二进制除法不同。"><a href="#二进制模2除法与二进制除法不同。" class="headerlink" title="二进制模2除法与二进制除法不同。"></a>二进制模2除法与二进制除法不同。</h3><h3 id="模2运算：加法不进位，减法不借位。"><a href="#模2运算：加法不进位，减法不借位。" class="headerlink" title="模2运算：加法不进位，减法不借位。"></a>模2运算：加法不进位，减法不借位。</h3><p><img src="/../images/image-20230908144721375.png" alt="image-20230908144721375"></p><p>二进制除法：<br>       带借位的二进制除法，根据余数减除数够减与否，确定商1还是商0，若够减则商1，否则商0。</p><p>二进制模2除法：<br>      采用模2减法，不带借位的二进制减法，因此考虑余数够减除数与否是没有意义 的。实际上，在CRC运算中，总能保证除数的首位为1，则模2除法运算的商是由余数首位与除数首位的模2除法运算结果确定。因为除数首位总是1，按照模2 除法运算法则，那么余数首位是1就商1，是0就商0。</p><p>（1）一步步的计算方法：</p><pre><code>模2除法与长除法类似，但有个特点：不借位。说白了就是按位异或，相同为0，不同为1。 </code></pre><p>它有三个原则：<br>   1、除数与被除数最高几位（与除数位数相同）做异或，商1。（除数首位必须为1）<br>   2、余数先去掉首位，若此时余数最高位为1，商1，并对以它为除数继续模2除。<br>         若最高位为0，则商0，重复步骤2。<br>   3、直到余数位数小于除数位数时，运算结束。 </p><p>（2）熟悉规则之后，比较简洁的方法</p><pre><code>  1、当余数位数与除数位数相同时，才进行异或运算，余数首位是1，商就是1，余数首位是0，商就是0。  2、当已经除了几位后，余数位数小于除数，商0，余数往右补一位，位数仍比除数少，则继续商0，当余数位数和除数位数一样时，商1，进行异或运算，得新的余数，以此至被除数最后一位。</code></pre><p><img src="/../images/image-20230908144752182.png" alt="image-20230908144752182"></p>]]></content>
      
      
      
        <tags>
            
            <tag> CRC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QCustomPlot的安装与使用</title>
      <link href="/2023/08/23/QCustomPlot%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/08/23/QCustomPlot%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>配置 QCustomPlot 的方式主要有两种, 一种是直接将  QCustomPlot 的相关库添加到所在的项目中, 直接调用相关库, 这种方式因为本身  QCustomPlot 中的逻辑也比较多, 那么在每次被调的时候都会生成一次, 降低了程序执行的效率, 因此我这里是使用了另一种方式; 第二种方式是本篇使用的方式, 通过生成动态链接库的方式调用  QCustomPlot 库, 这样就能避免函数重复编译, 提升程序执行效率. </p><h2 id="第一步-下载相关库"><a href="#第一步-下载相关库" class="headerlink" title="第一步: 下载相关库"></a>第一步: 下载相关库</h2><p>首先 QCustomPlot 属于是外部的库函数, 因此无法在qt核心中直接调用, 需要下载相关库</p><p>下载地址:  <a href="https://www.qcustomplot.com/index.php/download">https://www.qcustomplot.com/index.php/download</a> </p><p><img src="/../images/image-20230823100622234.png" alt="image-20230823100622234"></p><p>需要下载 QCustomPlot.tar.gz 和 QCustomPlot-sharedlib.tar.gz 两个文件<br>把QCustomPlot.gz解压后如下：</p><p><img src="/../images/image-20230823100758725.png" alt="image-20230823100758725"></p><p>把QCustomPlot-sharedlib.tar.gz解压后如下：</p><p><img src="/../images/image-20230823100853398.png" alt="image-20230823100853398"></p><h2 id="第二步-生成动态库"><a href="#第二步-生成动态库" class="headerlink" title="第二步: 生成动态库"></a>第二步: 生成动态库</h2><p>打开 QCustomPlot-sharedlib → sharedlib-compilation → sharedlib-compilation.pro, 编译器我用的是 MinGW32 , 这里常用的编译器应该都可以的. </p><p>然后在生成的项目中打开 .pro 文件, 如下图:</p><p><img src="/../images/image-20230823102802015.png" alt="image-20230823102802015"></p><p>注意这里两个地方, 第一个是上面的红框, 要在源代码后追加 printsupport ,  然后是后边的红框, 这里不需要变动只需要关注这两个文件在这里所检索读取的相对路径, 即根目录上两级下的位置, 此时需要将QCustomPlot文件夹中 qcustomplot.cpp和qcustomplot.h粘贴到这个相对路径位置. 然后开始构建项目, 在构建的 debug 和 release 文件夹内分别生成如下文件</p><p>dubug路径下:</p><p><img src="/../images/image-20230823103327031.png" alt="image-20230823103327031"></p><p>release路径下:</p><p><img src="/../images/image-20230823103347518.png" alt="image-20230823103347518"></p><p>完成上述步骤之后, 我们需要在另外的路径新建一个文件夹 命名为 “qcustomplotDLL”, 分别将debug中libqcustomplotd2.a和qcustomplotd2.dll；release中的libqcustomplot2.a和qcustomplot2.dll；QCustomPlot.tar.gz解压之后中的qcustomplot.cpp 和qcustomplot.h放到项目qcustomplot文件夹内, 如下图:</p><p><img src="/../images/image-20230823103753564.png" alt="image-20230823103753564"></p><p>以上动态库就生成完成了</p><h2 id="第三步-调用动态库"><a href="#第三步-调用动态库" class="headerlink" title="第三步: 调用动态库"></a>第三步: 调用动态库</h2><p>现在随便新建一个空项目, 构建完成后, 在项目一栏右击选择 “ 添加库… “, 在添加库中选择外部库</p><p><img src="/../images/image-20230823105103292.png" alt="image-20230823105103292"></p><p>点击下一步</p><p><img src="/../images/image-20230823105203959.png" alt="image-20230823105203959"></p><p>浏览选择第二步中最后生成的 qcustomplotDLL 文件夹中的 libqcustomplot2.a</p><p><img src="/../images/image-20230823105240784.png" alt="image-20230823105240784"></p><p><img src="/../images/image-20230823105320350.png" alt="image-20230823105320350"></p><p>取消不必要的勾选, 点击下一步</p><p><img src="/../images/image-20230823105417498.png" alt="image-20230823105417498"></p><p>点击完成:</p><p><img src="/../images/image-20230823105507484.png" alt="image-20230823105507484"></p><p>回到我们构建的新项目的 .pro 文件中, 红框中是新增的内容 , 这里有一个小插曲, 就是第二行中尾部的 2d 要变成  d2, 这里默认追加和文件名和我们动态库文件夹中的文件名不匹配, 改掉即可. </p><p><img src="/../images/image-20230823105524001.png" alt="image-20230823105524001"></p><p>到这里为止,  构建我们新建的这个空项目, 如果没有报错, 那么动态库就配置完成了, 配置完成之后, 要在 ui 中提升一下组件, 首先是在窗口中拖拽一个 widget</p><p><img src="/../images/image-20230823110654909.png" alt="image-20230823110654909"></p><p>右键单击这个控件, 在选项中选择 “ 提升为… “</p><p><img src="/../images/image-20230823110829755.png" alt="image-20230823110829755"></p><p>在提升的类名称中, 输入 QCustomPlot ( 头文件会自动涵盖 ), 之后点击添加</p><p><img src="/../images/image-20230823110917036.png" alt="image-20230823110917036"></p><p><img src="/../images/image-20230823111024619.png" alt="image-20230823111024619"></p><p>添加完成之后勾选全局包含, 最后点击提升, 这里就调用完成了, 现在开始运行项目</p><p><img src="/../images/image-20230823111146506.png" alt="image-20230823111146506"></p><p>可以看图表, 表明动态库已经被成功调用, 以上.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> QCustomPlot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记预罗列</title>
      <link href="/2023/08/04/%E7%AC%94%E8%AE%B0%E9%A2%84%E7%BD%97%E5%88%97/"/>
      <url>/2023/08/04/%E7%AC%94%E8%AE%B0%E9%A2%84%E7%BD%97%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>在这里我会把发现的新的但并不是多熟悉的知识点罗列一下, 并且简单的描述一遍, 目的是有序的把这些知识点练习掌握并梳理归纳下来. </p><h2 id="知识点罗列-计划中准备梳理归纳的知识点"><a href="#知识点罗列-计划中准备梳理归纳的知识点" class="headerlink" title="知识点罗列&amp;计划中准备梳理归纳的知识点:"></a>知识点罗列&amp;计划中准备梳理归纳的知识点:</h2><ol><li><p>使用qchart组件写一个demo, 建立对它的基本认识</p></li><li><p>对chartzoom进行深入的理解</p></li><li><p>初识QGraphicsScene和QGraphicsView, 了解基本概念</p></li><li><p>关于Q_PROPERTY 属性管理器 [重要]</p></li><li><p>数据库的相关操作总结</p></li><li><p>初识qml</p></li><li><p>整理常用容器的基本功能</p></li><li><p>qt导出pdf&#x2F;csv</p></li><li><p>modbusTCP通信原理</p></li><li><p>使用Qt Design Studio新建一个qml项目, 梳理相关知识点</p></li><li><p>Q_OBJECT在什么时候会报错的相关问题</p></li><li><p>enum Qt::WidgetAttribute相关</p></li><li><p>QThread</p></li><li><p>QThreadPool &#x2F; QQRunnable</p></li><li><p>Qt Concurrent</p></li><li><p>WorkerScript(QML)</p></li><li><p>Qt中的套接字通信和网络通信操作流程</p><p>​</p></li></ol><p>这个文档完成一条去掉一条, 基本上都会生成相关文档并上传到博客里.</p><p>下面是一些小的知识点或一些需要注意的细节, 没必要单独写成一篇文档, 我把这些零碎的知识点记录在这里.</p><p>1.(qt相关) 自定义信号槽 中, 如果是在当前的类下开辟的信号槽, 即发送者和接受者都是本类 this , 需要注意这种情况下 connect 的语法格式, 如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">connect</span>(<span class="keyword">this</span>,<span class="built_in">SIGNAL</span>(<span class="built_in">freshDeviceStatus</span>()),<span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">on_freshDeviceStatus</span>()));</span><br><span class="line"><span class="comment">//注意发送和信号都要使用格式包裹起来, 如果带参数记得补上参数</span></span><br></pre></td></tr></table></figure><ol start="2"><li></li></ol><p>一些链接:</p><p>测试相关: <a href="https://mp.weixin.qq.com/s/jUO2D5EokbNgZ3Yf0Nm13Q">https://mp.weixin.qq.com/s/jUO2D5EokbNgZ3Yf0Nm13Q</a></p><p>RFID二次开发相关: <a href="http://sdk.highwillow.cn:31213/">http://sdk.highwillow.cn:31213/</a></p><p>免费的一些接口:<a href="https://www.bejson.com/knownjson/webInterface/">https://www.bejson.com/knownjson/webInterface/</a></p><p>本地ip接口: <a href="http://whois.pconline.com.cn/ipJson.jsp?json=true">http://whois.pconline.com.cn/ipJson.jsp?json=true</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>加载中界面</title>
      <link href="/2023/07/17/%E5%8A%A0%E8%BD%BD%E4%B8%AD%E7%95%8C%E9%9D%A2/"/>
      <url>/2023/07/17/%E5%8A%A0%E8%BD%BD%E4%B8%AD%E7%95%8C%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<p>程序运行时会遇到卡顿的情况, 这种情况可能是读或是写操作中涉及到的数据较多, 也有一些其他的情况. 在这种卡顿的情况下, 如果程序的界面没有丝毫变化, 会很影响交互, 让用户误以为软件卡死, 并可能会被用户关闭软件, 因此我们的需求是在界面卡顿时, 给界面附带一个蒙板, 半透明的遮罩住原界面, 并在蒙板中心位置添加一个加载中的旋钮, 表示当前系统处于忙碌中. 以下我将分成两个部分来分别介绍如何完成这两步操作. [ 这里用的不是qml, 好像qml中有更好的解决方法, 需要的可以自行搜索 ] </p><h2 id="添加蒙板"><a href="#添加蒙板" class="headerlink" title="添加蒙板"></a>添加蒙板</h2><p>在添加蒙板之前, 我们首先需要分析, 蒙板是在什么情况下触发的? 蒙板被触发时应该是什么样的? 回答这些问题我们要回到项目本身, 我们的项目中可能存在多个ui, 它们的尺寸可能是不同的, 或者项目本身需要适配不同尺寸的屏幕, 那么也会涉及到ui界面的尺寸不同.  考虑到这些问题, 我们的蒙板的尺寸就绝不能给定值, ( 可能会有小伙伴会想, 那么我给一个超大的蒙板不就行了, 简单粗暴, 大小尺寸都能适配, 也不需要考虑七七八八, 我想说这样写一方面会影响程序加载效率, 而且显的非常的呆, 态度非常敷衍 ) 需要我们在调用蒙板的时候, 每次都获取一下当前屏幕的尺寸, 并resize蒙板的尺寸, 这样就能保证蒙板始终和忙碌时的界面保持尺寸一致. </p><p><img src="/../images/uiSample02_sRZL5lpN0N.gif" alt="uiSample02_sRZL5lpN0N"></p><p>尺寸问题确定之后, 接下来要考虑蒙板调用的形式和方式, 简单的说就是一定是在满足某种条件的情况下, 可以触发蒙板显示, 所以参照以下代码:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    m_mask_widget = <span class="keyword">new</span> mask_widget;<span class="comment">//这里就是蒙板</span></span><br><span class="line"></span><br><span class="line">    Form* obj = <span class="keyword">new</span> Form;</span><br><span class="line">    obj-&gt;<span class="built_in">show</span>();</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">setWidgetMask</span>(<span class="literal">true</span>,obj);<span class="comment">//这里是给窗口obj调用蒙板的函数</span></span><br><span class="line">    <span class="comment">//第一个参数是标志位, 表示蒙板的显示状态, false即为隐藏</span></span><br><span class="line">    <span class="comment">//可参照下面setWidgetMask函数</span></span><br><span class="line">        </span><br><span class="line">    m_persent = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//setWidgetMask函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::setWidgetMask</span><span class="params">(<span class="type">bool</span> showFlag, QWidget *pWidget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(showFlag)&#123;</span><br><span class="line">        m_mask_widget-&gt;<span class="built_in">setMainWidget</span>(pWidget);</span><br><span class="line">        m_mask_widget-&gt;<span class="built_in">show</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        m_mask_widget-&gt;<span class="built_in">hide</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给标志位的目的是在程序忙碌状态结束时, 要让蒙板隐藏</span></span><br></pre></td></tr></table></figure><p>接下来介绍一下 setMainWidget() 函数, 在之前我先说明一下这个函数的目的. 在我们调用蒙板的时候, 蒙板是不知道当前窗口的大小尺寸的, 所以我们需要设定一个带参函数, 把当前窗口的对象以参数的形式传输到函数中, 这是第一步.  第二步就是让蒙板认参做父, 参照代码如下:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mask_widget::setMainWidget</span><span class="params">(QWidget *pWidget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">resize</span>(pWidget-&gt;<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setParent</span>(pWidget);</span><br><span class="line">    <span class="comment">//这里的this即表示蒙板, 我们需要设定蒙板的尺寸为传入对象的尺寸</span></span><br><span class="line">    <span class="comment">//并设定传入的参数对象为蒙板窗口的父窗口,这样就可以让蒙板显示在父窗口中了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>完成上述步骤, 蒙板也就添加完成了, 接下来是第二步</p><h2 id="添加中心旋钮"><a href="#添加中心旋钮" class="headerlink" title="添加中心旋钮"></a>添加中心旋钮</h2><p><img src="/../images/image-20230817131444111.png" alt="image-20230817131444111"></p><p>添加旋钮一般有两种方式,:</p><p>第一种是在项目中引入外部的gif图片, 然后把这个图片放置在窗口中心位置显示 </p><p><img src="/../images/image-20230817132842695.png" alt="image-20230817132842695"></p><p>这种方式的优点是: 操作上方便, 直接在资源中引入即可, 而且选择的图片形式多样, 网上很多旋钮的样式可供选择. 当然同时也有缺点, 组件可能无法在ui界面中平滑显示, 组件边缘有锯齿感, 而且旋钮的尺寸\转速\转向都是固定的.</p><p>第二种是在项目中通过调用qt种绘图的相关库进行绘制, 这种方式也存在优缺点: 优点是通过绘图库绘制出来的旋钮通过设置抗锯齿可以平滑的显示, 除此之外, 旋钮的尺寸\转速\转向都是可调整的, 当然也存在缺点, 因为涉及编写图形绘制, 逻辑上相对复杂, 而且能绘制出什么样的样式, 写法也是不同的, 而且可以确定的是, 样式上越是”高级””花哨”的中心旋钮, 绘制曲线的代码逻辑也就越复杂.</p><p>下面分开讲解两种旋钮的调用方法:</p><p>首先是第一种调用方式, 需要我们在资源文件中添加我们选好的GIF图片, 如下图:</p><p><img src="/../images/image-20230821153749471.png" alt="image-20230821153749471"></p><p>如果有小伙伴这一步还不会操作请仔细查询方法, 这里不再赘述 (手要敲麻了) 接下来, 参照以下代码:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMovie&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span><span class="comment">//qmovie和qlabel 必要的头文件</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>( *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">initLabelStyleSheet</span>();</span><br><span class="line">    <span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: rgba(128, 128, 128, 128);&quot;</span>);</span><br><span class="line">    <span class="built_in">setWindowOpacity</span>(<span class="number">0.5</span>);</span><br><span class="line">    <span class="built_in">setWindowFlags</span>(Qt::FramelessWindowHint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::initLabelStyleSheet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QMovie *movie= <span class="keyword">new</span> <span class="built_in">QMovie</span>(<span class="string">&quot;:/res/loading.gif&quot;</span>);<span class="comment">//使用qmovie并设定路径,这里注意路径格式不要出错哦</span></span><br><span class="line">    QString labelStyleSheet = <span class="string">&quot;QLabel &#123;&quot;</span></span><br><span class="line">                              <span class="string">&quot;background-color: transparent;&quot;</span></span><br><span class="line">                              <span class="string">&quot;&#125;&quot;</span>;<span class="comment">//这里有必要把背景色的样式设定为透明</span></span><br><span class="line">    ui-&gt;label-&gt;<span class="built_in">setFixedSize</span>(<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line">    ui-&gt;label-&gt;<span class="built_in">setStyleSheet</span>(labelStyleSheet);</span><br><span class="line">    ui-&gt;label-&gt;<span class="built_in">move</span>((<span class="keyword">this</span>-&gt;<span class="built_in">width</span>()/<span class="number">2</span> + <span class="keyword">this</span>-&gt;<span class="built_in">x</span>() - <span class="number">100</span>),(<span class="keyword">this</span>-&gt;<span class="built_in">height</span>()/<span class="number">2</span> + <span class="keyword">this</span>-&gt;<span class="built_in">y</span>() - <span class="number">100</span>));<span class="comment">//这里要设定这个label的相对位置, 注意要考虑到label本身的尺寸</span></span><br><span class="line">    ui-&gt;label-&gt;<span class="built_in">setMovie</span>(movie);<span class="comment">//将GIF添加到label中去</span></span><br><span class="line">    movie-&gt;<span class="built_in">start</span>();<span class="comment">//让movie对象开始播放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就完成了第一种通过添加gif的方式添加加载中旋钮, 接下来是第二种方式.</p><p>在开始第二种方式之前,我需要先说明一下,第二种方式因为绘制的方式不同, 写法自然不是唯一的, 这里我使用了一种比较”low”的绘制方式供大家参考. 先上图:</p><p><img src="/../images/image-20230821160017879.png" alt="image-20230821160017879"></p><p>我绘制的原理是,首先绘制一个圆环, 让这个圆环作为底图, 然后以同样的圆心坐标和半径绘制一个圆弧, 最后让这个圆弧围绕这个圆心旋转, 就得到了这样一个加载中的旋钮, 如下图:</p><p><img src="/../images/uiSample03_zOpF5EIgwc.gif" alt="uiSample03_zOpF5EIgwc"></p><p>解下来上代码:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPaintEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: rgba(128, 128, 128, 128);&quot;</span>);</span><br><span class="line">    <span class="built_in">setWindowOpacity</span>(<span class="number">0.5</span>);</span><br><span class="line">    <span class="built_in">setWindowFlags</span>(Qt::FramelessWindowHint);</span><br><span class="line">    m_rotate = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">initLabelStyleSheet</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::initLabelStyleSheet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> labelSize = <span class="number">50</span>;</span><br><span class="line">    ui-&gt;label-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: rgba(128, 128, 128, 0);&quot;</span></span><br><span class="line">                             <span class="string">&quot;border-radius:25px;&quot;</span>);</span><br><span class="line">    ui-&gt;label-&gt;<span class="built_in">setFixedSize</span>(labelSize,labelSize);</span><br><span class="line">    ui-&gt;label-&gt;<span class="built_in">move</span>((<span class="keyword">this</span>-&gt;<span class="built_in">width</span>()/<span class="number">2</span> + <span class="keyword">this</span>-&gt;<span class="built_in">x</span>() - labelSize/<span class="number">2</span>),(<span class="keyword">this</span>-&gt;<span class="built_in">height</span>()/<span class="number">2</span> + <span class="keyword">this</span>-&gt;<span class="built_in">y</span>() - labelSize/<span class="number">2</span>));</span><br><span class="line">    ui-&gt;label-&gt;<span class="built_in">installEventFilter</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">slot_pushButton_pressed</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MainWindow::eventFilter</span><span class="params">(QObject *obj, QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj == ui-&gt;label &amp;&amp; event-&gt;<span class="built_in">type</span>() == QEvent::Paint)&#123;</span><br><span class="line">        <span class="comment">/**** 以下是底层圆环 ****/</span></span><br><span class="line">         <span class="function">QPainter <span class="title">painter2</span><span class="params">(ui-&gt;label)</span></span>;</span><br><span class="line">         painter2.<span class="built_in">setRenderHint</span>(QPainter::Antialiasing, <span class="literal">true</span>);</span><br><span class="line">         <span class="function">QPen <span class="title">pen2</span><span class="params">(Qt::black)</span></span>;</span><br><span class="line">         pen2.<span class="built_in">setWidth</span>(<span class="number">4</span>);</span><br><span class="line">         painter2.<span class="built_in">setPen</span>(pen2);</span><br><span class="line">         painter2.<span class="built_in">setBrush</span>(Qt::NoBrush);</span><br><span class="line">         <span class="type">int</span> width2 = ui-&gt;label-&gt;<span class="built_in">width</span>();</span><br><span class="line">         <span class="type">int</span> height2 = ui-&gt;label-&gt;<span class="built_in">height</span>();</span><br><span class="line">         <span class="function">QPointF <span class="title">center2</span><span class="params">(width2 / <span class="number">2.0</span>, height2 / <span class="number">2.0</span>)</span></span>;</span><br><span class="line">         <span class="function">QRectF <span class="title">rectangle2</span><span class="params">(center2.x()/<span class="number">2</span>, center2.y()/<span class="number">2</span>, width2 / <span class="number">2.0</span>, height2 / <span class="number">2.0</span>)</span></span>;</span><br><span class="line">         <span class="type">int</span> startAngle2 = (<span class="number">0</span>) * <span class="number">16</span>;</span><br><span class="line">         <span class="type">int</span> spanAngle2 = (<span class="number">360</span>) * <span class="number">16</span>;</span><br><span class="line">         painter2.<span class="built_in">drawArc</span>(rectangle2, startAngle2, spanAngle2);</span><br><span class="line">        <span class="comment">/**** 以上是底层圆环 ****/</span></span><br><span class="line"></span><br><span class="line">        <span class="function">QPainter <span class="title">painter</span><span class="params">(ui-&gt;label)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置抗锯齿效果</span></span><br><span class="line">        painter.<span class="built_in">setRenderHint</span>(QPainter::Antialiasing, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置画笔和画刷</span></span><br><span class="line">        <span class="function">QPen <span class="title">pen</span><span class="params">(Qt::white)</span></span>;</span><br><span class="line">        pen.<span class="built_in">setWidth</span>(<span class="number">4</span>);</span><br><span class="line">        painter.<span class="built_in">setPen</span>(pen);</span><br><span class="line">        painter.<span class="built_in">setBrush</span>(Qt::NoBrush);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制圆弧</span></span><br><span class="line">        <span class="type">int</span> width = ui-&gt;label-&gt;<span class="built_in">width</span>();</span><br><span class="line">        <span class="type">int</span> height = ui-&gt;label-&gt;<span class="built_in">height</span>();</span><br><span class="line">        <span class="function">QPointF <span class="title">center</span><span class="params">(width / <span class="number">2.0</span>, height / <span class="number">2.0</span>)</span></span>;</span><br><span class="line">        <span class="function">QRectF <span class="title">rectangle</span><span class="params">(center.x()/<span class="number">2</span>, center.y()/<span class="number">2</span>, width / <span class="number">2.0</span>, height / <span class="number">2.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> startAngle = (<span class="number">0</span> - <span class="built_in">getRotate</span>()) * <span class="number">16</span>;</span><br><span class="line">        <span class="type">int</span> spanAngle = (<span class="number">45</span>) * <span class="number">16</span>;</span><br><span class="line">        painter.<span class="built_in">drawArc</span>(rectangle, startAngle, spanAngle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MainWindow::getRotate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_rotate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::setRotate</span><span class="params">(<span class="type">int</span> rotate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_rotate=rotate;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::slot_pushButton_pressed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 旋转</span></span><br><span class="line">    pAnimationRotate = <span class="keyword">new</span> <span class="built_in">QPropertyAnimation</span>(<span class="keyword">this</span>, <span class="string">&quot;rotate&quot;</span>);</span><br><span class="line">    pAnimationRotate-&gt;<span class="built_in">setDuration</span>(<span class="number">1000</span>);</span><br><span class="line">    pAnimationRotate-&gt;<span class="built_in">setLoopCount</span>(<span class="number">-1</span>);</span><br><span class="line">    pAnimationRotate-&gt;<span class="built_in">setStartValue</span>(<span class="number">0</span>);</span><br><span class="line">    pAnimationRotate-&gt;<span class="built_in">setEndValue</span>(<span class="number">360</span>);</span><br><span class="line">    pAnimationRotate-&gt;<span class="built_in">setEasingCurve</span>(QEasingCurve::Linear);</span><br><span class="line">    pAnimationRotate-&gt;<span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要的代码都在这里了, 有问题或者需要源码的可以联系我.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> qss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渐进式界面</title>
      <link href="/2023/07/15/%E6%B8%90%E8%BF%9B%E5%BC%8F%E7%95%8C%E9%9D%A2/"/>
      <url>/2023/07/15/%E6%B8%90%E8%BF%9B%E5%BC%8F%E7%95%8C%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<p>启动程序时让程序从模糊过度到清晰, 是启动时的一种样式, 很简单我就不放图了, 下面是代码部分:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;openform.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_openform.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGraphicsBlurEffect&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPropertyAnimation&gt;</span></span></span><br><span class="line"><span class="comment">//这两个头文件必须包含</span></span><br><span class="line"></span><br><span class="line">OpenForm::<span class="built_in">OpenForm</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QWidget</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::OpenForm)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setWindowFlags</span>(Qt::FramelessWindowHint);</span><br><span class="line">    <span class="comment">//设置窗体样式</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">enterAnimationEffect</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OpenForm::~<span class="built_in">OpenForm</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenForm::enterAnimationEffect</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QGraphicsBlurEffect *blurEffect = <span class="keyword">new</span> <span class="built_in">QGraphicsBlurEffect</span>(<span class="keyword">this</span>);</span><br><span class="line">    blurEffect-&gt;<span class="built_in">setBlurRadius</span>(<span class="number">10</span>);<span class="comment">//设置模糊的半径</span></span><br><span class="line"></span><br><span class="line">    ui-&gt;frame-&gt;<span class="built_in">setGraphicsEffect</span>(blurEffect);</span><br><span class="line"></span><br><span class="line">    QPropertyAnimation *blurAnimation = <span class="keyword">new</span> <span class="built_in">QPropertyAnimation</span>(blurEffect, <span class="string">&quot;blurRadius&quot;</span>);</span><br><span class="line">    blurAnimation-&gt;<span class="built_in">setDuration</span>(<span class="number">3000</span>);<span class="comment">//这里是设置图像渐进的时间</span></span><br><span class="line">    blurAnimation-&gt;<span class="built_in">setStartValue</span>(<span class="number">50</span>);<span class="comment">//这里是起始的模糊度</span></span><br><span class="line">    blurAnimation-&gt;<span class="built_in">setEndValue</span>(<span class="number">0</span>);<span class="comment">//这里是最终的模糊度</span></span><br><span class="line">    blurAnimation-&gt;<span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> qss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2023/07/15/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/07/15/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>一个项目中可能存在多个界面窗口, 我们在调用某一个窗口的时候, 可能需要在主函数中声明这个窗口所对应的头文件, 还需要对其声明一个对象, 这个时候就需要考虑一个问题, 窗口对象在声明的时候相当于是初始化了一遍, 而在正常的程序使用过程中, 很多的窗口是不可以在每次被调的时候都初始化的. 举个例子, 存在一个列表窗口, 在首次显示的时候我们在里面填入了一些信息, 类似于 “name id password… “ 之类的, 我们是不希望这个窗口再次被打开时候之前录入的信息被释放掉, 清空掉的, 那么要达到这个目的, 就需要使用单例模式. 即子类对象在程序运行过程中有且仅只能被声明一次. 形式如下图: </p><p><img src="/../images/image-20230822163640844.png" alt="image-20230822163640844"></p><p>这些声明的指针对象在使用之前需要现在堆区开辟空间, 如下图:</p><p><img src="/../images/image-20230822163848112.png" alt="image-20230822163848112"></p><p>单例模式可以降低程序的复杂度, 提升程序的可读性, 对程序的维护和迭代有着重要的作用. </p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>脚本相关</title>
      <link href="/2023/07/07/%E8%84%9A%E6%9C%AC%E7%9B%B8%E5%85%B3/"/>
      <url>/2023/07/07/%E8%84%9A%E6%9C%AC%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>了解的较少, 但是还是做一点笔记, 首先是使用脚本启动程序, 还是使用记事本, 写好之后改变记事本后缀为.bat , 内容如下:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start D:\&quot;Program Files (x86)&quot;\Tencent\WeChat\WeChat.exe</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里需要注意某个路径如果带有空格或者中文或者中文符号, 这个路径要用引号括起来</span></span><br></pre></td></tr></table></figure><p>可以看到这个脚本是启动微信, 那么如何让这个脚本开机自动运行? 使用 ctrl + r 输入”shell:startup”, 回车会进入电脑的开启自启项目, 把我们改好的脚本文件, 放置在这个路径下, 开启时候就可以自动启动了, 如果我们需要开机启动多个软件, 在后序追加就行了, 类似以下写法:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start D:\&quot;Program Files (x86)&quot;\Tencent\WeChat\WeChat.exe</span><br><span class="line">start D:\&quot;Program Files (x86)&quot;\Tencent\QQ.exe</span><br><span class="line">start D:\&quot;Program Files (x86)&quot;\Tencent\WeGame.exe</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>还有一个知识点, 就是因为有些程序需要管理员权限, 那么我们再启动脚本的时候需要在脚本的顶部添加以下代码:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@echooff</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">1 mshta vbscript:CreateObject(<span class="string">&quot;Shell.Application&quot;</span>).ShellExecute(<span class="string">&quot;cmd.exe&quot;</span>,<span class="string">&quot;/c %~s0 ::&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;runas&quot;</span>,1)(window.close)&amp;&amp;<span class="built_in">exit</span></span></span><br><span class="line"></span><br><span class="line">cd/d &quot;%~dp0&quot;</span><br></pre></td></tr></table></figure><p>这样就能保证脚本是以管理员的身份启动的了, 自然启动的软件也都是管理员身份启动</p><p>目前先写到这里, 后续有新的了解会继续补充</p>]]></content>
      
      
      
        <tags>
            
            <tag> .bat </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件过滤器</title>
      <link href="/2023/07/06/%E4%BA%8B%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2023/07/06/%E4%BA%8B%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>在qt中, 可以通过事件过滤器, 对指定的控件添加事件响应, 举个例子, 假设存在一个QLineEdit控件, 正常情况下, 如果我在使用这个控件敲击键盘字母 “a” , 那么这个空间中肯定会显示 “a”, 通过事件过滤器, 可以捕获控件的指定状态, 我们可以让这个QLineEdit控件在输入字母 “a” 的指定状态的时候, 改成输入任何字符, 或者其他的什么操作, 下面就描述一下使用的方法: 整个过程就是两个步骤, 其实用起来比较简单, 分别是声明重载过滤器函数和给控件安装过滤器并添加逻辑.</p><h3 id="一-声明重载过滤器函数"><a href="#一-声明重载过滤器函数" class="headerlink" title="一  声明重载过滤器函数"></a>一  声明重载过滤器函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.h文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DIALOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIALOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDialog&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dialog</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dialog</span> : <span class="keyword">public</span> QDialog</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Dialog</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">Dialog</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *obj, QEvent *event)</span></span>;<span class="comment">//这里就是声明重载过滤器函数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::Dialog *ui;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DIALOG_H</span></span></span><br></pre></td></tr></table></figure><p>接下来要去.cpp中空实现一下</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Dialog::eventFilter</span><span class="params">(QObject *obj, QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="二-控件安装过滤器并添加逻辑"><a href="#二-控件安装过滤器并添加逻辑" class="headerlink" title="二  控件安装过滤器并添加逻辑"></a>二  控件安装过滤器并添加逻辑</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dialog.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_dialog.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QKeyEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line">Dialog::<span class="built_in">Dialog</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QDialog</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Dialog)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    ui-&gt;textEdit-&gt;<span class="built_in">installEventFilter</span>(<span class="keyword">this</span>);<span class="comment">//首先要确保ui控件已经添加, 然后给它安装事件过滤器</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Dialog::~<span class="built_in">Dialog</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Dialog::eventFilter</span><span class="params">(QObject *obj, QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//只有安装过事件过滤器的控件才能在事件过滤重载中被查询到,所以安装是必要的</span></span><br><span class="line">    <span class="keyword">if</span>(obj == ui-&gt;textEdit)<span class="comment">//过滤顾名思义就是筛选,当当前控件为ui-&gt;textEdit的时候,补充响应事件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(event-&gt;<span class="built_in">type</span>() == QEvent::KeyPress)</span><br><span class="line">        &#123;</span><br><span class="line">            QKeyEvent *keyEvent  =(QKeyEvent *)(event);</span><br><span class="line">            <span class="keyword">if</span>(keyEvent-&gt;<span class="built_in">key</span>() == Qt::Key_A)<span class="comment">//监听当键入的字符为 &quot;a&quot; 的时候</span></span><br><span class="line">            &#123;</span><br><span class="line">                ui-&gt;lineEdit-&gt;<span class="built_in">clear</span>();</span><br><span class="line">                ui-&gt;lineEdit_2-&gt;<span class="built_in">clear</span>();</span><br><span class="line">                ui-&gt;textEdit-&gt;<span class="built_in">clear</span>();</span><br><span class="line">                ui-&gt;lineEdit-&gt;<span class="built_in">setText</span>((<span class="string">&quot;输入的是A&quot;</span>));</span><br><span class="line">                ui-&gt;lineEdit_2-&gt;<span class="built_in">setText</span>((<span class="string">&quot;显示的是B&quot;</span>));</span><br><span class="line">                ui-&gt;textEdit-&gt;<span class="built_in">setText</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上</p><p>*相关问题:</p><h4 id="installEventFilter和installNativeEventFilter的区别"><a href="#installEventFilter和installNativeEventFilter的区别" class="headerlink" title="installEventFilter和installNativeEventFilter的区别?"></a><code>installEventFilter</code>和<code>installNativeEventFilter</code>的区别?</h4><p><code>installEventFilter</code> 和 <code>installNativeEventFilter</code> 都是 Qt 框架中用于安装事件过滤器的函数，但它们之间有一些区别。</p><ol><li><p><code>installEventFilter</code>：这个函数是 <code>QObject</code> 类的成员函数，用于在一个对象上安装一个普通事件过滤器。普通事件过滤器可以拦截和处理对象的各种事件，包括 Qt 框架封装的事件（例如按钮点击事件、键盘事件等）以及由应用程序自定义的事件。当安装了事件过滤器后，事件将首先传递给过滤器对象进行处理，然后再传递给原始的对象进行处理。</p></li><li><p><code>installNativeEventFilter</code>：这个函数是 <code>QCoreApplication</code> 或其派生类的成员函数，用于在应用程序上安装本机事件过滤器。本机事件过滤器用于处理底层窗口系统发送的原始事件，例如 Windows 平台的消息事件。通过安装本机事件过滤器，可以拦截并处理底层窗口系统发送的事件，而不是 Qt 框架封装后的事件。本机事件过滤器通常用于对底层操作系统进行更底层的访问和控制。</p></li></ol><p>总结起来，<code>installEventFilter</code> 用于安装普通事件过滤器，可以处理 Qt 框架中封装的事件，而 <code>installNativeEventFilter</code> 用于安装本机事件过滤器，可以处理底层窗口系统发送的原始事件。它们在处理事件的层级和范围上有所不同，开发者可以根据需要选择合适的过滤器类型。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>父子组件背景问题</title>
      <link href="/2023/07/05/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E8%83%8C%E6%99%AF%E9%97%AE%E9%A2%98/"/>
      <url>/2023/07/05/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E8%83%8C%E6%99%AF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>通常情况下, 在项目中的某一个ui界面我们需要使用美工做的图为背景图,像这样:</p><p><img src="/../images/image-20230810114619308.png" alt="image-20230810114619308"></p><p>此时我们会遇到一些问题, 假设我们需要添加一个QLineEdit组件, 像往常一样拖拽一个QLineEdit组件到我们已经设定了背景图的窗口中, 可以看到效果是这样的. </p><p><img src="/../images/image-20230810114900300.png" alt="image-20230810114900300"></p><p>首先, 我们的QLineEdit组件是设置有样式表的, 如下图</p><p><img src="/../images/image-20230810115121271.png" alt="image-20230810115121271"></p><p>但是为什么在拖拽到组件中我们的样式却消失了?</p><p>其实并不是, 当我们一个子组件拖拽到一个父组件的时候, 这个子组件会继承这个父组件的一些基本的样式信息, 这些基本样式信息中就含有背景图, 也就是说, 这个子组件继承了父组件的背景图.</p><p>所以, 为了避免这种情况影响到我们的需求, 我们再设定组件信息的时候需要初始化子组件的背景图路径, 设一个空路径, 如下图:</p><p><img src="/../images/image-20230810115518015.png" alt="image-20230810115518015"></p><p>注意, url() 中不要填写任何信息, 然后我们再次拖拽到父组件中查看效果, 如下图:</p><p><img src="/../images/image-20230810115624768.png" alt="image-20230810115624768"></p><p>可以看到我们再子组件设定的样式信息保留了下来</p>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> qss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存分区问题</title>
      <link href="/2023/07/04/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E9%97%AE%E9%A2%98/"/>
      <url>/2023/07/04/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>本篇介绍内存分区的相关问题, 网络上相关文章已经有很多了, 这里我会用自己理解认识的方式去描述.</p><p>首先如下图: 对初学者而言, 上来就撂给你一堆分区的概念的时候脑瓜子可能是嗡嗡的, 给人的感觉就是我是谁我在哪. 我认为要真正理解各个分区的概念, 需要在项目中具体使用到产生疑惑的时候, 再看对应的概念. 或许就能豁然开朗.</p><p><img src="/../images/20210319215715539.png"></p><h2 id="1-栈区"><a href="#1-栈区" class="headerlink" title="1. 栈区"></a>1. 栈区</h2><p>栈区由编译器自动分配释放，由操作系统自动管理，无须手动管理。一般可以理解为某一个函数中声明的变量, 并在函数中完成了它的生命周期, 其随着函数的的结束而被释放.<br>栈区按内存地址由高到低方向生长，其最大大小由编译时确定，速度快，但自由性差，最大空间不大。<br>栈区是先进后出原则，即先进去的被堵在屋里的最里面，后进去的在门口，释放的时候门口的先出去。<br>存放内容<br>临时创建的局部变量和const定义的局部变量存放在栈区。<br>函数调用和返回时，其入口参数和返回值存放在栈区。</p><h2 id="2-堆区"><a href="#2-堆区" class="headerlink" title="2. 堆区"></a>2. 堆区</h2><p>堆区由程序员分配内存和释放, 开发者手动开辟手动释放, 无释放在程序结束后自动释放.<br>堆区按内存地址由低到高方向生长，其大小由系统内存&#x2F;虚拟内存上限决定，速度较慢，但自由性大，可用空间大。<br>调用函数<br>用malloc等函数实现动态分布内存。c++中使用new在堆区开辟空间</p><p>void <em>malloc(size_t);<br>参数size_t是分配的字节大小。<br>返回值是一个void</em>型的指针，该指针指向分配空间的首地址。<br>（void *型指针可以任意转换为其他类型的指针）</p><p>用free函数进行内存释放，否则会造成内存泄漏。</p><p>void free(void * &#x2F;<em>ptr</em>&#x2F;);<br>参数是开辟的内存的首地址。</p><h2 id="3-全局-静态-区"><a href="#3-全局-静态-区" class="headerlink" title="3. 全局(静态)区"></a>3. 全局(静态)区</h2><p>通常是用于那些在编译期间就能确定存储大小的变量的存储区，但它用于的是在整个程序运行期间都可见的全局变量和静态变量。<br>全局区有 .bss段 和 .data段组成，可读可写。</p><h3 id="bss段"><a href="#bss段" class="headerlink" title=".bss段"></a>.bss段</h3><p>未初始化的全局变量和未初始化的静态变量存放在.bss段。<br>初始化为0的全局变量和初始化为0的静态变量存放在.bss段。<br>.bss段不占用可执行文件空间，其内容由操作系统初始化。</p><h3 id="data段"><a href="#data段" class="headerlink" title=".data段"></a>.data段</h3><p>已初始化的全局变量存放在.data段。<br>已初始化的静态变量存放在.data段。<br>.data段占用可执行文件空间，其内容有程序初始化。</p><h3 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点:"></a>需要注意的点:</h3><ol><li>在C++中, 静态全局变量独立于实例化对象之外, 一旦定义声明了静态全局的实例化对象, 在程序运行的整个周期, 这个变量会一直存在, 无法通过实例化的类的对象中对应的变量中对其进行修改, 因为通常在C++中我们声明一个类的对象, 并在堆区开辟可空间, 那么该类的对象中的相关成员都会在堆区中分配位置, 这个时候我们再对成员中的静态全局变量赋值, 相当于只赋值在了堆区的对象中, 而我们初始化的静态全局变量的值并没有发生任何改变. </li><li>在使用静态全局区的时候需要慎重, 非必要尽量要少用. 静态全局变量会增加程序负载, 挂载的静态全局变量越多程序负载越大效率越低, 这是第一点; 另外就是声明过多的静态全局变量会增加项目的复杂度, 不利于程序后期的开发和维护.</li></ol><h2 id="4-常量区"><a href="#4-常量区" class="headerlink" title="4. 常量区"></a>4. 常量区</h2><p>字符串、数字等常量存放在常量区。<br>const修饰的全局变量存放在常量区。<br>程序运行期间，常量区的内容不可以被修改。</p><h2 id="5-代码区"><a href="#5-代码区" class="headerlink" title="5. 代码区"></a>5. 代码区</h2><p>程序执行代码存放在代码区，其值不能修改（若修改则会出现错误）。<br>字符串常量和define定义的常量也有可能存放在代码区。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>json接口解析</title>
      <link href="/2023/06/09/json%E6%8E%A5%E5%8F%A3%E8%A7%A3%E6%9E%90/"/>
      <url>/2023/06/09/json%E6%8E%A5%E5%8F%A3%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>​常用的json接口大概有两种类型, 一个是简单的可以直接使用jsonArray解析的接口,  说人话就是, 接口返回的信息简单重复且单一, 另一个是使用jsonArray配合jsonObject使用的接口类型, 说人话就是, 接口返回的信息类型较为复杂, 可能包含多组数据信息. 下面会对如何解析这两种类型的返回接口举出实例进行讲解. </p><h2 id="json接口解析"><a href="#json接口解析" class="headerlink" title="json接口解析"></a>json接口解析</h2><p>这个是第一种:</p><p><img src="/../images/image-20230809141706160.png" alt="image-20230809141706160"></p><p>这是第二种:</p><p><img src="/../images/image-20230809142038049.png" alt="image-20230809142038049"></p><p>第一种解析逻辑比较简单, 暂时我就不写了 (以后有时间看心情补上(*￣︶￣) ), 主要是第二种解析方式, 第二种解析方式如果搞明白, 第一种其实也不必多说了.</p><h3 id="第一步-找到合适的接口"><a href="#第一步-找到合适的接口" class="headerlink" title="第一步: 找到合适的接口"></a>第一步: 找到合适的接口</h3><p>首先是找个接口, 这里我以百度热搜的接口为例</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该接口截止到我写的时候还能用, 如果不能用请自己找个接口练习</span></span><br><span class="line">https:<span class="comment">//top.baidu.com/api/board?platform=wise&amp;tab=realtime</span></span><br></pre></td></tr></table></figure><p>使用postman返回的格式如下:</p><p><img src="/../images/image-20230809143116595.png" alt="image-20230809143116595"></p><h3 id="第二步-明确要捕获的接口信息"><a href="#第二步-明确要捕获的接口信息" class="headerlink" title="第二步: 明确要捕获的接口信息"></a>第二步: 明确要捕获的接口信息</h3><p>我们以百度热搜榜为例, 要通过接口, 依次获取热搜标题, 并把这些标题展示在我们自定义的组件上</p><p><img src="/../images/image-20230809143539066.png" alt="image-20230809143539066"></p><p>首先是分析接口格式:</p><p><img src="/../images/image-20230809150712703.png" alt="image-20230809150712703"></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"># 这里是接口的返回值<span class="punctuation">,</span> 由于返回的内容较多<span class="punctuation">,</span>这里就不再全部展示</span><br><span class="line"># 以我们需要的信息具体分析</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;success&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;cards&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;component&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hotList&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;appUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;hotChange&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;hotScore&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;hotTag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;hotTagImg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;img&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> *<span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;indexUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;女儿不需要报销妈妈感慨自己没用了&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;rawUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;show&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;word&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;appUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;hotChange&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;hotScore&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;hotTag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;hotTagImg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;img&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> *<span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;indexUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;双胞胎暴雨中降生被起名定海神针&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;rawUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;show&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;more&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;moreAppUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;moreUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;topContent&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;appUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;hotChange&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;hotScore&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;hotTag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;img&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> *<span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;indexUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;rawUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;show&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;word&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;typeName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;updateTime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;curBoardName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;logid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;platform&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tag&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;api response ok&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>通过接口可以看到,我们最终需要的信息是 query 对应的值, 现在分析这个接口的结构, 首先不同于简单接口返回都是单一重复的array类型, 该接口上来就返回有几个不同的键:”success”&amp;”data”&amp;”error”, 然后逐下分层, 很明显我们需要的 “query” 在 “data” 这个对象里.</p><p>下面两个点需要注意的:</p><p>凡是冒号后跟 { } 的(例如”demo” :{ }) , 都是 QJsonObject类型;</p><p>凡是冒号后跟 [ ] 的(例如”demo” :[ ]) , 都是QJsonArray类型.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从根对象中获取&quot;data&quot;键对应的值</span></span><br><span class="line">QJsonObject dataObj = jsonObj[<span class="string">&quot;data&quot;</span>].<span class="built_in">toObject</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从&quot;data&quot;对象中获取&quot;cards&quot;键对应的值</span></span><br><span class="line">QJsonArray cardsArray = dataObj[<span class="string">&quot;cards&quot;</span>].<span class="built_in">toArray</span>();</span><br><span class="line"></span><br><span class="line">QStringList list;</span><br><span class="line"><span class="comment">// 由于&quot;cards&quot;键对应的值是一个数组，我们遍历这个数组</span></span><br><span class="line">foreach (<span class="type">const</span> QJsonValue &amp;cardVal, cardsArray) &#123;</span><br><span class="line">    <span class="comment">// 获取数组中的每个元素，这里假设每个元素都是一个对象</span></span><br><span class="line">    QJsonObject cardObj = cardVal.<span class="built_in">toObject</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在每个元素中查找&quot;content&quot;键对应的值</span></span><br><span class="line">    QJsonArray contentArray = cardObj[<span class="string">&quot;content&quot;</span>].<span class="built_in">toArray</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历&quot;content&quot;数组</span></span><br><span class="line">    foreach (<span class="type">const</span> QJsonValue &amp;contentVal, contentArray) &#123;</span><br><span class="line">        <span class="comment">// 获取数组中的每个元素</span></span><br><span class="line">        QJsonObject contentObj = contentVal.<span class="built_in">toObject</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取&quot;query&quot;键对应的值</span></span><br><span class="line">        QString query = contentObj[<span class="string">&quot;query&quot;</span>].<span class="built_in">toString</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这里可以使用获取到的&quot;appUrl&quot;值进行后续操作</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//qDebug() &lt;&lt;count&lt;&lt; query;//测试输出数据</span></span><br><span class="line">        query = QString::<span class="built_in">number</span>(count) + <span class="string">&quot;. &quot;</span> + query;</span><br><span class="line">        list.<span class="built_in">append</span>(query);<span class="comment">//保存对应信息</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>核心逻辑就是这些了, 其实逻辑比较简答, 就是涉及到具体json接口的时候如果比较复杂可能会比较绕脑子, 多测试一下就可以了. 下面是我的演示输出.</p><p><img src="/../images/image-20230809151041417.png" alt="image-20230809151041417"></p><p>懒得传了, 后续再上传仓库吧, 需要 demo 的可以联系我(*￣︶￣)</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Qt </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件打包</title>
      <link href="/2023/05/12/%E8%BD%AF%E4%BB%B6%E6%89%93%E5%8C%85%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2023/05/12/%E8%BD%AF%E4%BB%B6%E6%89%93%E5%8C%85%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<hr><p>简述: 打包方式千千万, 有一个自己用的熟悉且好用的打包方式, 能适配你很多打包的需求. 这里还需要培养自己规避异常的意识. </p><h3 id="程序打包之-SetupFactory"><a href="#程序打包之-SetupFactory" class="headerlink" title="程序打包之:  SetupFactory"></a>程序打包之:  SetupFactory<img src="/../images/image-20230803150722311.png" alt="image-20230803150722311"></h3><p>我目前主要使用这个软件打包, 下面我会从零开始打包一个软件, 这里我会把需要考虑到的问题和需要做的配置描述清楚. </p><p><img src="/../images/image-20230803150957503.png" alt="image-20230803150957503"></p><p>上图是软件主界面, 在我们打包软件之前, 首先需要拿到程序的可执行文件, 这里我们以Qt项目中构建的可执行文件(.exe)为例进行打包. </p><h3 id="一-找到可执行文件"><a href="#一-找到可执行文件" class="headerlink" title="一.  找到可执行文件"></a>一.  找到可执行文件</h3><p>​qt项目中, 构建目录中依照我们的构建方式 (release或者debug) ,可以在对应的文件夹中找到可执行文件, 如下图</p><p><img src="/../images/image-20230803151917456.png" alt="image-20230803151917456"></p><p>提示一下, 通常公司中的项目打包以release中的可执行文件为准, 不使用debug打包, 原因不再赘述</p><h3 id="二-配置必要的源文件"><a href="#二-配置必要的源文件" class="headerlink" title="二. 配置必要的源文件"></a>二. 配置必要的源文件</h3><p>在配置文件之前, 首先在自定义路径创建一个文件夹, 命名自定义 (我习惯使用”项目名+packet”) . 然后将我们找到的可执行文件(.exe) 拷贝到文件夹中.</p><p><img src="/../images/image-20230803152425850.png" alt="image-20230803152425850"></p><p>接下来是一些需要着重在意的步骤:</p><ol><li>首先项目是在qt中构建的, 所以我们应该配置必要qt核心库</li><li>在一些项目中, 可能存在一些外部配置文件, 这些外部文件可能是我们自定义的组件图片&#x2F; 必要的自定义组件样式表&#x2F; 必要的外部动态库&#x2F; 必要的外部数据库&#x2F; …  这些文件也需要根据其相对路径位置, 放到我们的同级目录下</li><li>对于开发者而言, 大多数情况下, 如果我们把打包前的准备工作做完, 程序在该路径下打开就可以”正常”运行了, 但这种”正常”并不一定是真的正常, 因为开发者电脑所处的环境已经配置好了所有必要的环境变量, 因此在配置好相关文件之后, 第一时间不需要打包程序, 把packet文件夹压缩一下, 拿到一个没有配置的任何环境变量的电脑里解压测试一下软件是否可以正常打开, 如果软件成功打开 ( 可以正常打开但是涉及到有外部样式组件的时候, 还是需要打开检查一下是否样式文件被配置到程序中了, 如果没有样式那就是位置放置有误 ) , 那么我们的打包前的准备就无误了, 否则还需要调整.</li></ol><p>接下来依次操作:</p><p>首先, 配置qt中必要的核心库, 这是qt项目中打包的必要步骤, 我们打开打包文件夹, 按住shift键右击鼠标, 点击 <u>在此处打开powershell窗口</u></p><p><img src="/../images/image-20230803154800969.png" alt="image-20230803154800969"></p><p>这里我们会自动定位当前位置所在路径:</p><p><img src="/../images/image-20230803154947859.png" alt="image-20230803154947859"></p><p>然后输入: “windeployqt  BMS_FirmwareUpgradePlatformV2.exe” </p><p><img src="/../images/image-20230803155310488.png" alt="image-20230803155310488"></p><p>这里要注意windeployqt 后是可执行文件的全称, 包括后缀.exe , 接下来点击回车</p><p><img src="/../images/image-20230803155435917.png" alt="image-20230803155435917"></p><p>这里就开始部署相关文件, 可以看到文件夹中添加了必要的配置文件</p><p><img src="/../images/image-20230803155541208.png" alt="image-20230803155541208"></p><p>以上我们完成了配置文件的第一个步骤, 然后我们要回到项目本身, 检查项目中是否存在外部配置文件, 把这些文件按照相对路基放到打包目录中去</p><p><img src="/../images/image-20230803160225658.png" alt="image-20230803160225658"></p><p>完成这一步确认没有遗漏之后, 我们需要把这个文件夹压缩一下, 拷贝到另一台没有配置任何环境的电脑中,  解压并打开检查是否能够正常打开 (可以正常打开但是涉及到有外部样式组件的时候, 还是需要打开检查一下是否样式文件被配置到程序中了, 如果没有样式那就是位置放置有误) , 如果可以说明配置完成, 否则需要补充配置文件. </p><p><img src="/../images/image-20230803160711288.png" alt="image-20230803160711288"></p><p>这里不再演示, 我们默认配置成功, 现在回到打包目录</p><p><img src="/../images/image-20230803160821432.png" alt="image-20230803160821432"></p><p>以上, 我们就完成了打包前必要文件的配置. 先别着急, 这里对于上述步骤中的 windeployqt 还需要多啰嗦一下,  你可以简单的这样理解, 不同的qt版本, 进行 windeployqt *.exe 产生的配置文件大小是不一样的, 这是我发现的, 我不确定版本是否向下兼容, 这个差异对项目的可执行是有影响的! 所以如果你不是某个项目的初次开发者, 在涉及到项目打包的时候, 一定要用前人的 windeployqt 配置产生的文件才能确保程序的运行 ( 别的开发环境也一样道理 ).</p><h3 id="三-开始打包-打包软件的基本信息配置"><a href="#三-开始打包-打包软件的基本信息配置" class="headerlink" title="三.  开始打包 &#x2F; 打包软件的基本信息配置"></a>三.  开始打包 &#x2F; 打包软件的基本信息配置</h3><p>回到开头, 我们软件打包的界面</p><p><img src="/../images/image-20230803161823976.png" alt="image-20230803161823976"></p><p>首先我们需要新建一个项目, 是的, 新建打包的项目, 现在不要迷糊</p><p><img src="/../images/image-20230803162234486.png" alt="image-20230803162234486"></p><p><img src="/../images/image-20230803162303996.png" alt="image-20230803162303996"></p><p>点击确定</p><p><img src="/../images/image-20230803162342579.png" alt="image-20230803162342579"></p><p>依次输入信息,点击下一页</p><p><img src="/../images/image-20230803162410778.png" alt="image-20230803162410778"></p><p>建议选择32位, 点击下一步</p><p><img src="/../images/image-20230803162509857.png" alt="image-20230803162509857"></p><p>这里需要选择你的ItemPacket文件夹所在的路径</p><p><img src="/../images/image-20230803162625735.png" alt="image-20230803162625735"></p><p><img src="/../images/image-20230803162635063.png" alt="image-20230803162635063"></p><p>点击下一页</p><p><img src="/../images/image-20230803162701624.png" alt="image-20230803162701624"></p><p>向导, 点击下一页</p><p><img src="/../images/image-20230803162724109.png" alt="image-20230803162724109"></p><p>这里主题就默认的, 后续根据自己需要变更即可, 点击下一页</p><p><img src="/../images/image-20230803162807454.png" alt="image-20230803162807454"></p><p>语言默认即可, 如果是跨境项目可能有必要添加相应语言, 点击下一页</p><p><img src="/../images/image-20230803162905966.png" alt="image-20230803162905966"></p><p>这里根据你的项目中是否需要必要的运行库进行添加, 一般不做勾选, 点击下一页</p><p><img src="/../images/image-20230803163012222.png" alt="image-20230803163012222"></p><p>默认勾选,点击完成</p><p><img src="/../images/image-20230803163030882.png" alt="image-20230803163030882"></p><p>此时打包文件夹中的所有文件都已经保存到了打包项目中, 此时需要注意</p><p><img src="/../images/image-20230803163140060.png" alt="image-20230803163140060"></p><p>双击可执行文件</p><p><img src="/../images/image-20230803163217091.png" alt="image-20230803163217091"></p><p>覆盖这一项需要设置为始终覆盖现有文件. 点击确定</p><p>选择打包前设置</p><p><img src="/../images/image-20230803163347415.png" alt="image-20230803163347415"></p><p><img src="/../images/image-20230803163425435.png" alt="image-20230803163425435"></p><p>这里可以自定义设置安装包的图标, 另外还有七七八八一堆功能, 不再一一描述, 还需要亲们自己去摸索了. 点击确定</p><p>点击发布按钮</p><p><img src="/../images/image-20230803163648914.png" alt="image-20230803163648914"></p><p><img src="/../images/image-20230803163708809.png" alt="image-20230803163708809"></p><p>默认单一文件</p><p><img src="/../images/image-20230803163747218.png" alt="image-20230803163747218"></p><p>设置安装包的生成路径, 和安装包的命名, 点击下一步</p><p><img src="/../images/image-20230803163841106.png" alt="image-20230803163841106"></p><p><img src="/../images/image-20230803163853348.png" alt="image-20230803163853348"></p><p>点击完成</p><p><img src="/../images/image-20230803163916050.png" alt="image-20230803163916050"></p><p>项目打包成功, 这里不再展示安装</p>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> 软件打包 </tag>
            
            <tag> SetupFactory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt重启程序</title>
      <link href="/2023/05/01/Qt%E9%87%8D%E5%90%AF%E7%A8%8B%E5%BA%8F/"/>
      <url>/2023/05/01/Qt%E9%87%8D%E5%90%AF%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>一些项目中的程序会涉及读写本地文件, 在变更了本地文件参数之后, 一些读取的逻辑只会在启动的时候执行一次, 所以在这种情况下, 会导致此时程序参与逻辑计算的数据还是第一次启动时候未变更的数据. 特别是一些复杂的项目, 类似涉及到绘图, 或者实时显示的一些逻辑. 为了防止在变更后不影响新的参数参与逻辑, 所以需要让程序重新启动一下, 这里直接展示代码:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::reboot</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    QString program = QApplication::<span class="built_in">applicationFilePath</span>();  </span><br><span class="line">    QStringList arguments = QApplication::<span class="built_in">arguments</span>();  </span><br><span class="line">    QString workingDirectory = QDir::<span class="built_in">currentPath</span>();  </span><br><span class="line">      </span><br><span class="line">    QProcess *process = <span class="keyword">new</span> <span class="built_in">QProcess</span>();  </span><br><span class="line">    <span class="keyword">if</span> (process-&gt;<span class="built_in">startDetached</span>(program, arguments, workingDirectory)) &#123;  </span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Restart successful!&quot;</span>;  </span><br><span class="line">        QApplication::<span class="built_in">exit</span>();  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Failed to restart application!&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建动态链接库.dll(Dynamic Link Library)</title>
      <link href="/2023/04/03/%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"/>
      <url>/2023/04/03/%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>本篇介绍如何使用qt创建一个动态链接库,并如何使用自己创建的动态库.</p><p><img src="/../images/image-20230803140633332.png" alt="image-20230803140633332"></p><hr><h2 id="创建动态链接库："><a href="#创建动态链接库：" class="headerlink" title="创建动态链接库："></a>创建动态链接库：</h2><p><img src="/../images/image-20230803141250596.png" alt="image-20230803141250596"></p><p><img src="/../images/image-20230803141350915.png" alt="image-20230803141350915"></p><p><img src="/../images/image-20230803141417812.png" alt="image-20230803141417812"></p><p><img src="/../images/image-20230803141433542.png" alt="image-20230803141433542"></p><p><img src="/../images/image-20230803141451031.png" alt="image-20230803141451031"></p><p><img src="/../images/image-20230803141543224.png" alt="image-20230803141543224"></p><p><img src="/../images/image-20230803141559439.png" alt="image-20230803141559439"></p><p>项目创建完成之后可以看到三个文件,这里库函数中的功能函数要写在mydll.h和mydll.cpp中,如果比较复杂可以添加新的.h&#x2F;.cpp, 下面以此为例</p><p><img src="/../images/image-20230803141652147.png" alt="image-20230803141652147"></p><p>首先在mydll.h中声明我们需要封装的功能函数并在cpp中实现并写入功能</p><p><img src="/../images/image-20230803142324755.png" alt="image-20230803142324755"></p><p><img src="/../images/image-20230803142538825.png" alt="image-20230803142538825"></p><p>此时动态库已经编辑完成,保存之后构建项目</p><p><img src="/../images/image-20230803142726500.png" alt="image-20230803142726500"></p><p>构建完成之后找到构建目录,从对应的构建方式下找到对应的.dll文件</p><p><img src="/../images/image-20230803142905635.png" alt="image-20230803142905635"></p><p><img src="/../images/image-20230803142938036.png" alt="image-20230803142938036"></p><p>此时动态链接库文件已经生成完成,接下来讲解如何调用我们生成的动态库</p><h2 id="调用动态链接库"><a href="#调用动态链接库" class="headerlink" title="调用动态链接库:"></a>调用动态链接库:</h2><p>要调用自定义的动态库, 首先创建一个默认的qt项目,这里不再展示创建过程</p><p><img src="/../images/image-20230803143436798.png" alt="image-20230803143436798"></p><p>项目创建完成之后,首先进入项目所在的路径,穿件两个文件夹,分别命名为lib和include, 这里lib文件夹中存放.dll文件, include文件夹中把我们生成动态库文件的项目中的头文件.h放进来. </p><p><img src="/../images/image-20230803143700235.png" alt="image-20230803143700235"></p><p><img src="/../images/image-20230803143811304.png" alt="image-20230803143811304"></p><p><img src="/../images/image-20230803143833559.png" alt="image-20230803143833559"></p><p>完成以上操作之后, 回到QT我们创建的项目, 进入.pro文件, 在文件中添加我们创建的路径信息</p><p><img src="/../images/image-20230803144253959.png" alt="image-20230803144253959"></p><p><img src="/../images/image-20230803144226004.png" alt="image-20230803144226004"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加include文件夹</span></span><br><span class="line">INCLUDEPATH += $$PWD/include</span><br><span class="line"><span class="comment">//添加lib文件夹, 并加入名为&quot;mydll&quot;的.dll文件, 这里需要注意语法-l后追加文件名</span></span><br><span class="line">LIBS += -L$$PWD/lib -lmydll</span><br></pre></td></tr></table></figure><p>以上就完成了动态库的路径配置, 接下里是动态库的调用</p><p><img src="/../images/image-20230803145034953.png" alt="image-20230803145034953"></p><p>完成之后运行项目项目</p><p><img src="/../images/image-20230803145218801.png" alt="image-20230803145218801"></p><p>这里我们就成功的在项目中调用了自建的动态链接库</p>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> 动态链接库 </tag>
            
            <tag> .dll </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态链接库.dll(Dynamic Link Library)</title>
      <link href="/2023/03/11/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2023/03/11/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>在一些有特定需求对的项目中可能会用到动态链接库, 如果是标准的动态链接库我们找到它对应的接口调用其功能即可, 而在一些特定的情况下我们可能需要自定义动态链接库. 本篇主要阐释动态链接库的基本概念,后续我会更新如何自定义一个动态链接库文件,以及如何在自己的项目中调用自定义的动态链接库.</p><hr><h2 id="动态链接库："><a href="#动态链接库：" class="headerlink" title="动态链接库："></a>动态链接库：</h2><h3 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h3><p>动态链接库（Dynamic Link Library，DLL）是一种在Windows操作系统中常见的可执行文件格式，用于存储可被应用程序动态加载和使用的代码和数据。与静态链接库不同，动态链接库在程序运行时才会被加载，并且可以被多个应用程序共享。</p><p>以下是动态链接库的一些特点和优势：</p><ol><li><p>动态加载：动态链接库可以在程序运行时通过操作系统的动态链接机制被加载到内存中。这意味着只有在需要使用库中的函数或符号时才会加载，可以减少内存占用和启动时间。</p></li><li><p>共享使用：多个应用程序可以同时使用同一个动态链接库。这样可以避免代码的重复，节省存储空间，并且可以实现代码的统一更新和维护。</p></li><li><p>动态更新：由于动态链接库是独立于应用程序的，因此可以方便地对库进行更新和升级。应用程序无需重新编译和发布，只需要替换库文件即可。</p></li><li><p>模块化设计：动态链接库可以将功能模块化，使得代码更易于组织、维护和复用。通过将相关的功能封装在动态链接库中，可以实现高内聚、低耦合的设计。</p></li><li><p>符号解析：动态链接库中的函数和符号可以被应用程序动态解析和调用。通过获取函数指针或符号地址，应用程序可以直接调用库中的函数，实现与库的交互和功能扩展。</p></li></ol><p>动态链接库在实际应用中有广泛的应用场景，例如插件系统、共享组件、第三方库的使用等。它们提供了一种灵活、高效的方式来扩展和增强应用程序的功能。同时，动态链接库也需要注意版本兼容性、依赖关系等问题，以确保应用程序能够正确加载和使用库。</p><h3 id="包含信息"><a href="#包含信息" class="headerlink" title="包含信息"></a>包含信息</h3><p>动态链接库（Dynamic Link Library，DLL）是一种可被多个程序共享使用的代码和数据的集合。在Windows操作系统中，DLL文件通常包含以下几类信息：</p><ol><li><p>导出函数：DLL文件可以包含一个或多个可供其他程序调用的函数。这些函数被称为导出函数，可以通过函数名来调用。导出函数定义了DLL提供给其他程序的接口。</p></li><li><p>导入函数：DLL文件可以引用其他DLL文件或操作系统提供的函数。这些函数被称为导入函数，可以在DLL文件中使用，但是它们的实现在其他DLL文件或操作系统中。导入函数定义了DLL依赖的接口。</p></li><li><p>数据段：DLL文件可以包含一些静态数据，这些数据可以被多个程序共享。这些数据可以存储全局变量、常量、配置信息等。</p></li><li><p>资源：DLL文件可以包含一些资源，例如图标、位图、字符串等。这些资源可以在程序运行时被其他程序或操作系统使用。</p></li></ol><p>DLL文件的内部信息通常以一种特定的格式进行存储和组织。在Windows操作系统中，DLL文件的格式遵循PE（Portable Executable）格式，这是一种可移植可执行文件的格式。PE格式定义了DLL文件的头部信息、节区信息、导入表、导出表、符号表等。这些信息描述了DLL的结构和内容，使得操作系统和其他程序能够正确加载和使用DLL文件中的代码和数据。</p><p>需要注意的是，DLL文件的具体格式和内容可能会因不同的操作系统或编程语言而有所差异，上述信息仅是一般情况下的常见特征。</p><h3 id="生成步骤"><a href="#生成步骤" class="headerlink" title="生成步骤"></a>生成步骤</h3><p>要生成一个动态链接库（DLL），你可以按照以下步骤进行操作：</p><ol><li><p>选择编程语言：首先，选择你熟悉的编程语言。常用的编程语言如C&#x2F;C++、C#、Java等都提供了生成DLL的支持。</p></li><li><p>编写代码：使用你选择的编程语言编写DLL代码。在代码中定义导出函数（可供其他程序调用的函数）和其他需要共享的数据。</p></li><li><p>声明导出函数：在DLL代码中，需要使用适当的语法和关键字来声明导出函数。这可以告诉编译器将这些函数作为DLL的导出函数进行处理。</p></li><li><p>编译代码：使用编译器将DLL代码编译为二进制文件。编译时，应该指定生成动态链接库的选项，以确保生成正确的文件类型。</p></li><li><p>链接库文件：将编译生成的二进制文件链接为DLL文件。这通常需要使用特定的工具或命令来完成。链接过程将把DLL文件与所需的运行时库和其他依赖项进行关联。</p></li><li><p>测试和调试：编译和链接成功后，你可以对生成的DLL文件进行测试和调试。确保导出函数的功能正确，并且DLL在其他程序中能够正常加载和使用。</p></li></ol><p>需要注意的是，生成DLL的具体步骤可能因所使用的编程语言和开发环境而有所差异。建议参考相应编程语言的文档或教程，以了解特定语言和工具的详细操作步骤。</p><p>以下是使用C++语言生成动态链接库（DLL）的基本示例：</p><ol><li><p>创建一个新的C++源文件，例如example.cpp。</p></li><li><p>在example.cpp中编写DLL的代码，包括导出函数和其他需要共享的数据。以下是一个简单的示例：</p></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function"><span class="type">int</span> <span class="title">AddNumbers</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他需要共享的数据</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="type">int</span> sharedData = <span class="number">42</span>;</span><br></pre></td></tr></table></figure><p>在此示例中，AddNumbers函数是一个导出函数，可以被其他程序调用。sharedData是一个共享的整数变量。</p><ol start="3"><li>使用C++编译器（如g++或Visual C++）编译源代码，并将其生成为DLL文件。以下是使用g++编译器的示例命令行：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ -shared -o example.dll example.cpp</span><br></pre></td></tr></table></figure><p>此命令将源文件example.cpp编译为名为example.dll的动态链接库文件。</p><ol start="4"><li>编译成功后，将生成的example.dll文件与所需的运行时库和其他依赖项一起使用。你可以在其他C++程序中加载和调用该DLL提供的函数，或让其他语言的程序调用。</li></ol><p>请注意，在不同的操作系统和编译环境下，生成DLL的具体命令和选项可能会有所不同。建议参考你所使用的编译器和开发环境的文档，以了解相应的生成DLL方法和选项。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 动态链接库 </tag>
            
            <tag> .dll </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程_join()</title>
      <link href="/2023/02/15/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B_join()/"/>
      <url>/2023/02/15/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B_join()/</url>
      
        <content type="html"><![CDATA[<h2 id="join"><a href="#join" class="headerlink" title="join()"></a><strong>join()</strong></h2><p>​假设存在一个主线程中有一个子线程，主线程执行周期为500ms，而子线程中的业务逻辑稍微复杂一点，执行所用的时间周期更长大概需要800ms。那么在中情况下，如果任凭事情发展，最终的结果会是，子线程的业务逻辑还未执行完毕就随着主线程的结束而直接终止了。为了防止这种情况的发生就有了join()函数。</p><p>​使用方法：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> num, string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;num: &quot;</span> </span><br><span class="line">             &lt;&lt; num &lt;&lt; <span class="string">&quot;, str: &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">download1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 模拟下载, 总共耗时500ms，阻塞线程500ms</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程1: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">download2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 模拟下载, 总共耗时300ms，阻塞线程300ms</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">300</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程2: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;....主线程来了....&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* cout &lt;&lt; &quot;主线程的线程ID: &quot; &lt;&lt; this_thread::get_id() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    thread t(func, 123, &quot;abc&quot;);</span></span><br><span class="line"><span class="comment">    // 需要注明的是，thread声明的对象应含有这种形式：</span></span><br><span class="line"><span class="comment">    // 首先是函数的名称，然后依次传入该函数对应类型的函数参数    </span></span><br><span class="line"><span class="comment">    thread t1(func1);</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &quot;线程t 的线程ID: &quot; &lt;&lt; t.get_id() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &quot;线程t1的线程ID: &quot; &lt;&lt; t1.get_id() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    t.join();</span></span><br><span class="line"><span class="comment">    t1.join();*/</span></span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(download1)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(download2)</span></span>;</span><br><span class="line">    <span class="comment">// 阻塞主线程，等待所有子线程任务执行完毕再继续向下执行</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">doSomething</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如代码中，通过声明的类的对象调用join()函数实现线程阻塞。输出的结果为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子线程2: 72540</span></span><br><span class="line"><span class="comment">// 子线程1: 79776</span></span><br><span class="line"><span class="comment">// ....主线程来了....</span></span><br></pre></td></tr></table></figure><p>通过输出结果可以看出，主线程是在子线程调用完毕之后再调用的，说明主线程已经被阻塞执行，确保了子线程的完整运行。</p><p><u>需要注意的是：在阻塞线程的时候，一定要注意我们阻塞的是哪个线程，线程在哪个线程被执行，就阻塞哪个线程。</u></p><p>以上(*￣︶￣)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> C++11 </tag>
            
            <tag> C++ </tag>
            
            <tag> join() </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程_datach()</title>
      <link href="/2023/02/13/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B_detach()/"/>
      <url>/2023/02/13/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B_detach()/</url>
      
        <content type="html"><![CDATA[<h2 id="detach"><a href="#detach" class="headerlink" title="detach()"></a><strong>detach()</strong></h2><p>​“从前一户人家的孩子非常叛逆，家里人已经管不了他了，他离家出走开始了自己独立的生活，后来家里触犯了律法，被满门抄斩，这个离家出走的孩子也依然会被株连。”</p><p>​存在某一种情况，我们需要单独执行某一个线程下的子线程，而且需要在执行这个子线程时，不会影响原有的线程。这个时候就需要用到线程分离函数detach()</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> num, string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;num: &quot;</span> </span><br><span class="line">             &lt;&lt; num &lt;&lt; <span class="string">&quot;, str: &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">download1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 模拟下载, 总共耗时500ms，阻塞线程500ms</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程1: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">download2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 模拟下载, 总共耗时300ms，阻塞线程300ms</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">300</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程2: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;....主线程来了....&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程的线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func, <span class="number">123</span>, <span class="string">&quot;abc&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 需要注明的是，thread声明的对象应含有这种形式：</span></span><br><span class="line">    <span class="comment">// 首先是函数的名称，然后依次传入该函数对应类型的函数参数    </span></span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程t 的线程ID: &quot;</span> &lt;&lt; t.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程t1的线程ID: &quot;</span> &lt;&lt; t1.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">    t1.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="comment">// 让主线程休眠，等待子线程执行结束</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">second</span>(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：线程分离不会阻塞线程，子主线程分离之后，在主线程中就不能再对该子线程进行任何控制了，比如：通过 join () 阻塞主线程等待子线程中的任务执行完毕，或者调用 get_id () 获取子线程的线程 ID等。有利就有弊，鱼和熊掌不可兼得，建议使用 join ()。</p><p>以上(*￣︶￣)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> detach() </tag>
            
            <tag> C++11 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Qt中.pri文件</title>
      <link href="/2023/01/17/%E5%85%B3%E4%BA%8EQt%E4%B8%AD.pri%E6%96%87%E4%BB%B6/"/>
      <url>/2023/01/17/%E5%85%B3%E4%BA%8EQt%E4%B8%AD.pri%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>​通过Qt创建的项目中，例如通常情况下的小项目，较少用到.pri文件。但是在中型或大型项目当中，需要把项目中的各个功能模块化，分隔开独立开发。这个时候就需要用到.pri文件取分支项目。以下是.pri的创建流程：</p><ol><li><p>首先在创建好的项目中右键.pro文件→在Explorer中打开，打开项目所在路径</p></li><li><p>在项目所在的路径中新建一个文件夹并命名demo</p></li><li><p>在文件夹中新建txt文件，并重命名为demo.pri</p></li><li><p>回到Qt，在Qt界面中的pro文件中添加</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">include</span>($$PWD/demo/demo.pri)</span><br><span class="line"><span class="comment">//$$：环境变量名</span></span><br></pre></td></tr></table></figure></li><li><p>添加完成后保存，等待一会儿就可以看到，项目中新添加了新的demo类目，其中存在demo.pri文件</p></li><li><p>这样分化的类目的基本雏形就存在了，接下来是在这个类目中添加新的.h&#x2F;.cpp和ui文件(注：并非所有的类目都需要ui文件，这里会分开说明)</p></li><li><p>a.如果不需要ui文件：右击新添加的类目，从选项中选择添加新文件，选择“C&#x2F;C++”，然后按照正常的项目创建流程创建即可；</p><p>b.如果需要ui文件：依然是单击右键，选择添加新文件，选择”Qt”，在这一类目中选择”Qt 设计器界面类”，然后按照正常流程创建即可</p></li><li><p>以上这两种方式在创建完成时，会在.pri文件中直接生成引用源，不需要再次声明</p><h3 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题:"></a>需要注意的问题:</h3><p>​在项目的中涉及到添加.pri文件的时候, 一般情况下我们的需求可能就是把某几组 .h&#x2F;cpp&#x2F;.ui 文件放置在同一个pri下方便管理, 这里可能会涉及到一些已有的 .h&#x2F;cpp&#x2F;.ui 文件需要转移到 .pri 目录下, 方法是直接逐个拖动过去即可, 在这之后变更调用这些文件 ( 如.h文件 ) 的位置的相对路径即可.</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Qt </tag>
            
            <tag> .pri </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Qt中.pro文件</title>
      <link href="/2023/01/17/%E5%85%B3%E4%BA%8EQt%E4%B8%AD.pro%E6%96%87%E4%BB%B6/"/>
      <url>/2023/01/17/%E5%85%B3%E4%BA%8EQt%E4%B8%AD.pro%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>本文主要列举说明在qt中新建项目生成的pro文件中，所涉及到的一些类目，可能不全，后续会再补充。</p><ol><li>QT +&#x3D; 是添加QT项目需要的模块 QT-&#x3D;是排除或者移除某个模块</li><li>HEADERS：.h文件</li><li>SOURCES：.cpp文件</li><li>FORMS：指定需要uic处理的ui文件</li><li>RESOURCES：指定需要rcc处理的qrc文件</li><li>DEFINES：指定预定义预处理器符号</li><li>INCLUDEPATH：指定C++编译器搜索头文件路径</li><li>LIBS：指定工程要链接的库</li><li>CONFIG：指定工程配置和编译参数</li><li>QT：指定工程所要使用的Qt模块</li><li>VERSION：指定目标库版本号</li><li>TARGET：指定可执行文件或库的基本文件名，默认为当前目录名</li><li>DESTDIR：指定可执行文件放置的目录</li><li>DLLDESTDIR：指定目标库文件放置的目录</li><li>RC_ICONS：添加icon</li><li>include:引入头文件或者pri文件</li><li>PWD:指的是当前正在解析的.pro文件的目录的完整路径</li><li>OUT_PWD:指的是qmake生成的Makefile的目录的完整路径</li><li>message:pro文件里面的打印输出</li><li>win32：条件编译</li></ol><h3 id="其中几个比较重要的说明："><a href="#其中几个比较重要的说明：" class="headerlink" title="其中几个比较重要的说明："></a>其中几个比较重要的说明：</h3><p>LIBS：指定工程要链接的库</p><p>LIBS 相对来说是比较重要的，因为在一些开发当中经常需要添加第三方库。这个时候就需要用LIBS来引入第三方库到工程中</p><p>LIBS的格式：    LIBS +&#x3D; -L路径 库名字</p><p>eg:            LIBS +&#x3D; -L$$PWD&#x2F;Demo_Pri&#x2F; -lvisa32d<br>#######################################################################################<br>-L :表示Local 即库的位置<br>-l :表示库本身 即库的名称<br>[注意不需要加dll&#x2F;so等后缀(QT跨平台比较强，后缀名为根据平台自动选择)]<br>####################################################################################### </p><p>自动拷贝<a href="https://so.csdn.net/so/search?q=dll%E6%96%87%E4%BB%B6&spm=1001.2101.3001.7020">dll文件</a>的方法：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">法<span class="number">1</span>：</span><br><span class="line">#利用cpoys 这个命令</span><br><span class="line">cp_kk.files += \</span><br><span class="line">            chartdir50.dll</span><br><span class="line">cp_kk.path  += $$OUT_PWD/release</span><br><span class="line">COPIES +=  cp_kk</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">法<span class="number">2</span>：</span><br><span class="line">#QMAKE_SUBSTITUTES</span><br><span class="line">DLL.input =  chartdir50.dll</span><br><span class="line">DLL.output = $$OUT_PWD/release/chartdir50.dll</span><br><span class="line">DLL.CONFIG = verbatim # 完全复制</span><br><span class="line">QMAKE_SUBSTITUTES += DLL</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Qt </tag>
            
            <tag> .pro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物联网智能家居-智能开关</title>
      <link href="/2022/12/25/%E7%89%A9%E8%81%94%E7%BD%91%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85-%E6%99%BA%E8%83%BD%E5%BC%80%E5%85%B3/"/>
      <url>/2022/12/25/%E7%89%A9%E8%81%94%E7%BD%91%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85-%E6%99%BA%E8%83%BD%E5%BC%80%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>这几天阳性在家，这个智能开关是小半个多月之前就计划制作了。本身并不是很难的东西。不过中间买错了东西，耽误了点时间，刚好赶上休息时间东西到了，也就把东西做出来了。</p><hr><h2 id="首先是硬件材料的准备："><a href="#首先是硬件材料的准备：" class="headerlink" title="首先是硬件材料的准备："></a>首先是硬件材料的准备：</h2><p>基于ESP8266的ESP-01、Relay模块、CH340C</p><p>就这三个东西，在拼多多上直接买都有，一共下来大概不到20块钱</p><hr><h2 id="接下来是环境的配置："><a href="#接下来是环境的配置：" class="headerlink" title="接下来是环境的配置："></a>接下来是环境的配置：</h2><p>1.首先是安装Arduino(这个没什么难度，注意自己把安装的分区分好，别放C盘，路径上最好是别有中文和空格)；</p><p>2.在手机上下载一个blinker，这个是人家做好的物联网app，就直接拿来用了，以后还是打算自己写一个哈哈。</p><p>3.只安装好Arduino还不行，需要在软件中补充开发板信息，找到<u>开发板管理器</u>，然后搜索ESP8266，很有可能找不到，这个时候你需要首先在<u>首选项</u>里的<u>其他开发板管理器地址</u>中添加<a href="http://arduino.esp8266.com/stable/package_esp8266com_index.json%EF%BC%8C%E7%84%B6%E5%90%8E%E4%BF%9D%E5%AD%98%E4%B8%80%E4%B8%8B%EF%BC%8C%E5%86%8D%E6%B7%BB%E5%8A%A0%E5%BC%80%E5%8F%91%E6%9D%BF%E8%AF%95%E8%AF%95%E3%80%82%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E9%9D%9E%E5%B8%B8%E6%85%A2%E3%80%82%E5%A6%82%E6%9E%9C%E5%AB%8C%E6%85%A2%E5%8F%AF%E4%BB%A5%E5%8E%BBGit%E4%B8%8A%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%EF%BC%8C%E6%94%BE%E5%9C%A8%E7%9B%AE%E6%A0%87%E7%9B%AE%E5%BD%95%E9%87%8C%E5%8D%B3%E5%8F%AF%E3%80%82">http://arduino.esp8266.com/stable/package_esp8266com_index.json，然后保存一下，再添加开发板试试。这个过程非常慢。如果嫌慢可以去Git上直接下载，放在目标目录里即可。</a></p><p>4.完成以上步骤后，还差一个步骤。我们在使用blinker这个app的时候，在烧录的代码里需要用到&lt;Blinker.h&gt;的头文件的库函数。这个也需要我们在Arduino中自己搜索添加。在管理库这个选项中，搜索blinker，有两个，我都下载了哈哈，反正没多大。</p><p>5.接下来就可以烧录了。直接上代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BLINKER_WIFI</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Blinker.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> auth[] = <span class="string">&quot;75*****27&quot;</span>; <span class="comment">//点灯科技设备KEY</span></span><br><span class="line"><span class="type">char</span> ssid[] = <span class="string">&quot;A**X&quot;</span>;  <span class="comment">//WIFI名称-只支持2.4G</span></span><br><span class="line"><span class="type">char</span> pswd[] = <span class="string">&quot;B******6&quot;</span>; <span class="comment">//WIFI密码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bt1 5</span></span><br><span class="line"><span class="comment">// #define bt2 4</span></span><br><span class="line"><span class="comment">// #define bt3 0</span></span><br><span class="line"><span class="comment">// #define bt4 2</span></span><br><span class="line"><span class="comment">// 新建组件对象</span></span><br><span class="line"><span class="function">BlinkerButton <span class="title">Button1</span><span class="params">(<span class="string">&quot;btn1&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按下按键即会执行该函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">button1_callback</span><span class="params">(<span class="type">const</span> String &amp; state)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">BLINKER_LOG</span>(<span class="string">&quot;get button state: &quot;</span>, state);</span><br><span class="line">  <span class="keyword">if</span> (state == <span class="string">&quot;on&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">digitalWrite</span>(bt1, LOW);</span><br><span class="line">    <span class="comment">// 反馈开关状态</span></span><br><span class="line">    Button1.<span class="built_in">print</span>(<span class="string">&quot;on&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="string">&quot;off&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">digitalWrite</span>(bt1, HIGH);</span><br><span class="line">    <span class="comment">// 反馈开关状态</span></span><br><span class="line">    Button1.<span class="built_in">print</span>(<span class="string">&quot;off&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化串口</span></span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line">  <span class="comment">// 初始化有LED的IO</span></span><br><span class="line">  <span class="built_in">pinMode</span>(bt1, OUTPUT);</span><br><span class="line">  <span class="built_in">digitalWrite</span>(bt1, HIGH);</span><br><span class="line">  <span class="comment">// 初始化blinker</span></span><br><span class="line">  Blinker.<span class="built_in">begin</span>(auth, ssid, pswd);</span><br><span class="line">  Button1.<span class="built_in">attach</span>(button1_callback);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Blinker.<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就基本完成了，接上自己家里的灯就可以使用了。之后我会再补充和完善一些功能。最近写的还有不少笔记没来得及发出来，最近一两周看如果有时间的话我就发出来。</p>]]></content>
      
      
      
        <tags>
            
            <tag> IoT </tag>
            
            <tag> ESP8266 </tag>
            
            <tag> Arduino </tag>
            
            <tag> blinker </tag>
            
            <tag> 智能家居 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QPushButton/QLabel鼠标悬浮（划过， hover）、选中（单击， pressed）状态下更换图标样式</title>
      <link href="/2022/12/03/QPushButtonQLabel%E9%BC%A0%E6%A0%87%E6%82%AC%E6%B5%AE(%E5%88%92%E8%BF%87%EF%BC%8C%20hover)%E9%80%89%E4%B8%AD(%E5%8D%95%E5%87%BB,pressed)%E7%8A%B6%E6%80%81%E4%B8%8B%E6%9B%B4%E6%8D%A2%E5%9B%BE%E6%A0%87%E6%A0%B7%E5%BC%8F/"/>
      <url>/2022/12/03/QPushButtonQLabel%E9%BC%A0%E6%A0%87%E6%82%AC%E6%B5%AE(%E5%88%92%E8%BF%87%EF%BC%8C%20hover)%E9%80%89%E4%B8%AD(%E5%8D%95%E5%87%BB,pressed)%E7%8A%B6%E6%80%81%E4%B8%8B%E6%9B%B4%E6%8D%A2%E5%9B%BE%E6%A0%87%E6%A0%B7%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>有三种方式：1.样式表2.event()3.evenfilter()</p><ol><li><h2 id="样式表"><a href="#样式表" class="headerlink" title="样式表"></a>样式表</h2><p>第一种方法：在样式表中设置 border-image（在网上看到有人使用 background-image 的，不推荐，因为那样的话图标大小是不会自动缩放的，有兴趣的可以试一下）。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QPushButton *button1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line">button1-&gt;<span class="built_in">setFixedSize</span>(<span class="number">30</span>, <span class="number">30</span>);</span><br><span class="line">button1-&gt;<span class="built_in">setFlat</span>(<span class="literal">true</span>);</span><br><span class="line">button1-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QPushButton&#123;border-image:url(:/listBar_Icon/add.png);&#125;&quot;</span></span><br><span class="line">                       <span class="string">&quot;QPushButton:hover&#123;border-image:url(:/listBar_Icon/add_hover.png);&#125;&quot;</span></span><br><span class="line">                       <span class="string">&quot;QPushButton:pressed&#123;border-image:url(:/listBar_Icon/add_pressed.png);&#125;&quot;</span></span><br><span class="line">                       );</span><br></pre></td></tr></table></figure><p>优点 ：简单方便。<br>缺点 : border-image 会随着 QPushButton 的大小尺寸变化（图标会填充整个按钮）。上面的例子中按钮形状和图标素材都是正方形的，所以效果不错。如果 QPushButton 只显示图标的话用这种方法比较好，如果需要添加文字而导致按钮形状和素材不同，这种方法则不可取。</p></li><li><h2 id="event"><a href="#event" class="headerlink" title="event()"></a>event()</h2><p>第二种方法：继承 QPushButton，重写 event 事件。效果和第一个 gif 相同。</p><p>MyPushButton.h</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPushButton</span> : <span class="keyword">public</span> QPushButton</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyPushButton</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setUpIcon</span><span class="params">(<span class="type">const</span> QIcon &amp;icon, <span class="type">const</span> QIcon &amp;icon_hover, <span class="type">const</span> QIcon &amp;icon_pressed)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">event</span><span class="params">(QEvent *event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QIcon Img, Img_hover, Img_pressed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>MyPushButton.c</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyPushButton::<span class="built_in">MyPushButton</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QPushButton</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPushButton::setUpIcon</span><span class="params">(<span class="type">const</span> QIcon &amp;icon, <span class="type">const</span> QIcon &amp;icon_hover, <span class="type">const</span> QIcon &amp;icon_pressed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Img = icon;</span><br><span class="line">    Img_hover = icon_hover;</span><br><span class="line">    Img_pressed = icon_pressed;</span><br><span class="line">    <span class="built_in">setIcon</span>(Img);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyPushButton::event</span><span class="params">(QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event-&gt;<span class="built_in">type</span>()) &#123;</span><br><span class="line">    <span class="keyword">case</span> QEvent::Enter:</span><br><span class="line">        <span class="built_in">setIcon</span>(Img_hover);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QEvent::Leave:</span><br><span class="line">        <span class="built_in">setIcon</span>(Img);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QEvent::MouseButtonPress:</span><br><span class="line">        <span class="built_in">setIcon</span>(Img_pressed);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QEvent::MouseButtonRelease:</span><br><span class="line">        <span class="built_in">setIcon</span>(Img_hover);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QPushButton::<span class="built_in">event</span>(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 MyPushButton</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyPushButton *button2 = <span class="keyword">new</span> <span class="built_in">MyPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line">button2-&gt;<span class="built_in">setFixedSize</span>(<span class="number">60</span>, <span class="number">30</span>);</span><br><span class="line">button2-&gt;<span class="built_in">setFlat</span>(<span class="literal">true</span>);</span><br><span class="line">button2-&gt;<span class="built_in">setUpIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/listBar_Icon/add.png&quot;</span>), <span class="built_in">QIcon</span>(<span class="string">&quot;:/listBar_Icon/add_hover.png&quot;</span>), <span class="built_in">QIcon</span>(<span class="string">&quot;:/listBar_Icon/add_pressed.png&quot;</span>));</span><br><span class="line">button2-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QPushButton&#123;border:0px solid rgba(0, 0, 0, 255);&#125;&quot;</span>);</span><br><span class="line">button2-&gt;<span class="built_in">setIconSize</span>(<span class="built_in">QSize</span>(<span class="number">30</span>, <span class="number">30</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>优点 ：图标显示效果不会受到按钮尺寸影响，只由setIconSize(QSize)控制。</li><li>缺点 ：有点复杂</li></ul></li><li><h2 id="evenfilter"><a href="#evenfilter" class="headerlink" title="evenfilter()"></a>evenfilter()</h2><p>第三种方法：原理及优缺点和第二种方法相同，只是不需要继承 QPushButton，而是重写主窗口的事件过滤器。</p><p>主窗口.h：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">test</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPushButton *button3 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initUi</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *obj, QEvent *event)</span> <span class="keyword">override</span></span>;  <span class="comment">//事件过滤</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主窗口.c：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">test::<span class="built_in">test</span>(QWidget *parent) : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">initUi</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test::initUi</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    button3 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line">    button3-&gt;<span class="built_in">setFixedSize</span>(<span class="number">30</span>, <span class="number">30</span>);</span><br><span class="line">    button3-&gt;<span class="built_in">setFlat</span>(<span class="literal">true</span>);</span><br><span class="line">    button3-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/listBar_Icon/add.png&quot;</span>));</span><br><span class="line">    button3-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QPushButton&#123;border:0px solid rgba(0, 0, 0, 255);&#125;&quot;</span>);</span><br><span class="line">    button3-&gt;<span class="built_in">setIconSize</span>(<span class="built_in">QSize</span>(<span class="number">30</span>, <span class="number">30</span>));</span><br><span class="line">    button3-&gt;<span class="built_in">installEventFilter</span>(<span class="keyword">this</span>);  <span class="comment">//安装事件过滤器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">test::eventFilter</span><span class="params">(QObject *obj, QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event-&gt;<span class="built_in">type</span>()) &#123;</span><br><span class="line">    <span class="keyword">case</span> QEvent::HoverEnter:</span><br><span class="line">        <span class="keyword">if</span>(obj == button3)</span><br><span class="line">            button3-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/listBar_Icon/add_hover.png&quot;</span>));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QEvent::HoverLeave:</span><br><span class="line">        <span class="keyword">if</span>(obj == button3)</span><br><span class="line">            button3-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/listBar_Icon/add.png&quot;</span>));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QEvent::MouseButtonPress:</span><br><span class="line">        <span class="keyword">if</span>(obj == button3)</span><br><span class="line">            button3-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/listBar_Icon/add_pressed.png&quot;</span>));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QEvent::MouseButtonRelease:</span><br><span class="line">        <span class="keyword">if</span>(obj == button3)</span><br><span class="line">            button3-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/listBar_Icon/add_hover.png&quot;</span>));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QWidget::<span class="built_in">eventFilter</span>(obj, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>如果需要在按钮中添加文字，那么只能使用后面两种方法。 QLabel和QPushButton差不多，不再赘述。</p><p>以上，(*￣︶￣)</p>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> QPushButton </tag>
            
            <tag> QLabel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈你对拷贝构造函数和赋值运算符的认识</title>
      <link href="/2022/11/23/%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E8%AE%A4%E8%AF%86/"/>
      <url>/2022/11/23/%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E8%AE%A4%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>我们在通过类定义一个对象</p><p>比如:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">stu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">stu</span>(<span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">m_age = a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过如下方式产生一个拷贝构造函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">stu <span class="title">p1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">stu <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br></pre></td></tr></table></figure><p>这样，p2就是通过编译器为我们自动进行了一次浅拷贝</p><p>[待补充…]</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
            <tag> 面试题 </tag>
            
            <tag> 拷贝构造函数 </tag>
            
            <tag> 函数重载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>static关键字在C语言和C++中的使用及区别</title>
      <link href="/2022/11/23/static%E5%85%B3%E9%94%AE%E5%AD%97%E5%9C%A8C%E8%AF%AD%E8%A8%80%E5%92%8CC++%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/11/23/static%E5%85%B3%E9%94%AE%E5%AD%97%E5%9C%A8C%E8%AF%AD%E8%A8%80%E5%92%8CC++%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="一、总述"><a href="#一、总述" class="headerlink" title="一、总述"></a>一、总述</h2><p>由于C++兼容C语言，所以<strong>static在C语言中的用法对于C++是同样适用的</strong>。两者的不同就是C++中多出来的特性，而这些特性与C++面线对象的特性有关。</p><h2 id="二、static在C语言中的作用（C-通用）"><a href="#二、static在C语言中的作用（C-通用）" class="headerlink" title="二、static在C语言中的作用（C++通用）"></a>二、static在C语言中的作用（C++通用）</h2><h3 id="1、修饰变量"><a href="#1、修饰变量" class="headerlink" title="1、修饰变量"></a>1、修饰变量</h3><h4 id="a、修饰全局变量（全局变量与静态全局变量的对比）"><a href="#a、修饰全局变量（全局变量与静态全局变量的对比）" class="headerlink" title="a、修饰全局变量（全局变量与静态全局变量的对比）"></a>a、修饰全局变量（全局变量与静态全局变量的对比）</h4><p>​修饰全局变量：作用域仅限于变量被定义的文件中，其他文件即使用extern声明也无法直接使用此变量，extern用法详见这里。（可以间接访问，即通过本文件的非static函数返回static变量的值，类似于C++类中的private变量外界没有权限访问，但是可以通过public函数返回private变量的值）。<br>​对比：全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同，且都只初始化一次，但静态全局变量对其他文件不可见，全局变量是可见的。<br>​总结：把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。  </p><h4 id="b、修饰局部变量"><a href="#b、修饰局部变量" class="headerlink" title="b、修饰局部变量"></a>b、修饰局部变量</h4><p>​修饰局部变量：在函数内定义的局部变量被修饰，可以延长变生命周期，但是作用域不变，只初始化一次。<br>​对比：普通局部变量定义后，出了作用域就会被释放，静态局部变量生命周期到程序结束才结束。<br>​总结：把局部变量改变为静态变量后是改变了它的存储方式，让静态局部变量出了作用域依然存在，到程序结束，生命周期才结束。</p><h3 id="2、修饰函数"><a href="#2、修饰函数" class="headerlink" title="2、修饰函数"></a>2、修饰函数</h3><p>和全局变量一样，函数的定义和声明默认情况下是extern的，但静态函数只是在声明它的文件当中可见，不能被其他文件所用。</p><h2 id="三、static在C-中的作用"><a href="#三、static在C-中的作用" class="headerlink" title="三、static在C++中的作用"></a>三、static在C++中的作用</h2><p>C+ +重用了这个关键字，并赋予它与前面不同的含义：表示属于一个类而不是属于此类的任何特定对象的变量和函数。</p><h3 id="1、静态数据成员"><a href="#1、静态数据成员" class="headerlink" title="1、静态数据成员"></a>1、静态数据成员</h3><p>静态数据成员是属于整个类的，而不是属于某个对象。即不管实例多少个对象，它们都公用一个静态数据成员（如：使用静态数据成员统计类已经实例化了多少对象）。</p><p>在c++中，普通数据成员在构造函数的函数体或初始化表中初始化；常量数据成员(const int a )必须在构造函数的初始化表中初始化（const对象或引用只能初始化但是不能赋值。构造函数的函数体内只能做赋值而不是初始化）；而静态数据成员(static int b )则必须在类外初始化（int 类名::b&#x3D;100），这是因为静态数据成员不属于任何一个对象，而是属于整个类的。</p><h3 id="2、静态成员函数"><a href="#2、静态成员函数" class="headerlink" title="2、静态成员函数"></a>2、静态成员函数</h3><p>静态成员函数是属于整个类的，而不是属于某个对象。静态成员函数可以被该类的所有对象直接访问；静态成员函数本身只能访问静态成员，不可以访问非静态成员。</p><h2 id="四、常见面试题–为什么static变量值只初始化一次？"><a href="#四、常见面试题–为什么static变量值只初始化一次？" class="headerlink" title="四、常见面试题–为什么static变量值只初始化一次？"></a>四、常见面试题–为什么static变量值只初始化一次？</h2><p>对于所有的对象（不仅仅是静态对象），初始化都只有一次，初始化后，一直都没有被销毁&#x2F;释放，都会保存在内存区域中，所以不会再次初始化。存放在静态区的变量的生命周期与整个程序“同生死、共存亡”，所以它只需初始化一次。而auto变量，即自动变量，由于它存放在栈区，一旦函数调用结束，就会立刻被销毁。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> static </tag>
            
            <tag> C </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深拷贝和浅拷贝</title>
      <link href="/2022/11/11/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2022/11/11/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Team</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;默认函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Team</span>(<span class="type">int</span> a,<span class="type">int</span> b) 含参的构造函数</span><br><span class="line">&#123;</span><br><span class="line">m_A = a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Team</span>(<span class="type">const</span> Team &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;复制函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Team</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> m_A;</span><br></pre></td></tr></table></figure><p>如上面的代码。当我们在调用一个有参的构造函数声明变量  c1 并对其赋值时，我们可以通过重新使用该类声明一个新的变量 c2 ，在赋值的 ( ) 中，将已经赋值过的变量 c1 填入，即 c2(c1)。通过这样的方式 ，我们可以得到一个赋值好的 c2 变量。其中 c2 中的赋值和 c1 是相同的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Team c1(18);//含参的构造函数</span><br><span class="line">cout &lt;&lt; c1 &lt;&lt; endl;</span><br><span class="line">Team c2(c1);</span><br><span class="line">cout &lt;&lt; c2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>以上，我们是通过编译器自动生成了一次对有参函数变量的浅拷贝。</p><p>但是，有时候我们会遇到一些问题。</p><hr><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>首先要知道，堆区：由<strong>程序员</strong>分配释放，若程序员不释放，程序结束后由操作系统回收（运行期间你不管，它就不释放。运行结束就给他回收掉）</p><p>在C++中主要利用<strong>new</strong>在堆区开辟内存</p><p>回到刚刚的代码。可以看到，在Team这个类当中，只有一组参数，那就是 int m_A；m_A是整形变量。那么如果我们的参数中含有指针变量呢？如果含有指针变量，我们的函数还可以按照刚刚浅拷贝那样，由编译器即可自动完成拷贝吗？</p><p>实际上是行不通的。我们需要从浅拷贝的机制来分析。</p><p>在编译器中简单的套用有参变量去传递参数的值的时候(浅拷贝)，实质上就是一种值的传递。而当我们类中的参数含有指针变量，且指针的变量是在堆区开辟的空间，且我们选择手动在最后类的析构函数中释放这段开辟的空间的时候，编译器就会报错。这是为什么？</p><p>首先这也是一种值的传递没有错，但是这个值的传递是对于指针变量来说的，对于普通变量，值的传递就是变量中存储的值的传递。但指针就比较特殊了，指针中存储的“值”，实际上就是地址。这个地址中也存储着值。而这个地址中所存储的值，才是我们需要拷贝，需要传递的值。*(其实说到底还是指针的那些概念)</p><p>所以很明显，问题出在了析构那里。正因为我们选择了在析构函数中手动的释放堆区开辟的空间。所以我们进行了两次析构函数的调用，但其实早在第一次的时候，由于堆区的空间被释放，类中的指针成员所指向的地址和地址里的内容就已经被释放了。那么我们在第二次拷贝参数的时候，就会遇到<strong>堆区的内存被重复释放</strong>这种情况。一旦出现这种情况，编译器会判定为非法操作，自然也就报错了。那么应该如何处理呢？</p><p>以上的拷贝操作实际上是由编译器自动完成的，为了防止堆区的空间被重复释放，我们需要自己定义一个拷贝构造函数就可以解决。</p><p>首先，我们需要在堆区重新申请一块儿内存。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Team</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Team</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;默认函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Team</span>(<span class="type">int</span> a,<span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">m_A = a;</span><br><span class="line">p = <span class="keyword">new</span> <span class="built_in">int</span>(b);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Team</span>(<span class="type">const</span> Team &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;复制函数&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译器默认的实现方式(浅拷贝)</span></span><br><span class="line"><span class="comment">//m_A = a.m_A;</span></span><br><span class="line"><span class="comment">//p = a.p;</span></span><br><span class="line"></span><br><span class="line">        p = <span class="keyword">new</span> <span class="built_in">int</span>(*a.p);<span class="comment">//在堆区重新申请一块儿内存(深拷贝)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Team</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Team <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">160</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; *c1.p &lt;&lt; endl;</span><br><span class="line"><span class="function">Team <span class="title">c2</span><span class="params">(c1)</span></span>;</span><br><span class="line">cout &lt;&lt; *c2.p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 深拷贝 </tag>
            
            <tag> 浅拷贝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windowsAPI</title>
      <link href="/2022/10/23/windowsAPI/"/>
      <url>/2022/10/23/windowsAPI/</url>
      
        <content type="html"><![CDATA[<p>网上查了windowsAPI函数, 发现函数实在很多, 这里留存两个相关链接当做字典用, 笔记中我会把自己用过的用到的API函数记录下来. </p><p>相关链接:</p><p>Win32API参考手册<a href="http://www.yfvb.com/help/win32sdk/index.htm?page=html/1n6cv5o.htm">http://www.yfvb.com/help/win32sdk/index.htm?page=html/1n6cv5o.htm</a></p><p>Windows API 参考手册  <a href="http://www.office-cn.net/t/api/index.html?web.htm">http://www.office-cn.net/t/api/index.html?web.htm</a></p><p>Windows API函数大全（Windows编程参考手册） <a href="https://blog.csdn.net/Aliven888/article/details/110942737">https://blog.csdn.net/Aliven888/article/details/110942737</a></p><p>笔记:</p>]]></content>
      
      
      
        <tags>
            
            <tag> windowsAPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建</title>
      <link href="/2022/10/22/hexo%20%E6%90%AD%E5%BB%BA/"/>
      <url>/2022/10/22/hexo%20%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>—#安装git<br>git工具在外网直接下载非常慢，需要在镜像环境中下载<br>如果电脑上有360，可以通过360的软件软件安装管家搜索git，可直接下载</p><p>—#安装Nodejs<br>node -v#查看node版本<br>npm -v#查看npm版本<br>npm install -g cnpm –registry&#x3D;<a href="http://registry.npm.taobao.org/">http://registry.npm.taobao.org</a>#安装淘宝的cnpm 管理器<br>cnpm -v#查看cnpm版本<br>cnpm install -g hexo-cli    #安装hexo框架<br>hexo -v#查看hexo版本<br>mkdir blog#创建blog目录<br>cd blog #进入blog目录<br>sudo hexo init #生成博客 初始化博客<br>hexo s#启动本地博客服务<br><a href="http://localhost:4000/">http://localhost:4000/</a>#本地访问地址<br>hexo n “我的第一篇文章” #创建新的文章<br>#返回blog目录<br>hexo clean #清理<br>hexo g #生成<br>#Github创建一个新的仓库 YourGithubName.github.io</p><h2 id="cnpm-install-–save-hexo-deployer-git-在blog目录下安装git部署插件"><a href="#cnpm-install-–save-hexo-deployer-git-在blog目录下安装git部署插件" class="headerlink" title="cnpm install –save hexo-deployer-git #在blog目录下安装git部署插件"></a>cnpm install –save hexo-deployer-git #在blog目录下安装git部署插件</h2><h2 id="配置-config-yml"><a href="#配置-config-yml" class="headerlink" title="#配置_config.yml "></a>#配置_config.yml </h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:<span class="comment">//hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.这里需要注意在Windows环境下type后边有一个&#x27;&#x27;符号，需要把git写在&#x27;&#x27;里</span></span><br><span class="line"><span class="comment">    2.type:和repo:后边都需要加一个空格  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">type: git </span><br><span class="line">repo: https:<span class="comment">//benwang717.github.io</span></span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><hr><p>hexo d#部署到Github仓库里<br>&#x2F;*<br>到这里基本上就已经部署完成了，有几个需要注意的点：<br>1.在最初安装好git之后，Windows环境下 记得在 hexo d 之前敲<br>    git config –global user.email “xxx” 设置一个你自己的邮箱<br>    git config –global user.name “xxx”  设置你的昵称</p><p>2.在完成上述步骤之后，如果执行 hexo d 依然有错误</p><p>类似于”OpenSSL SSL_read: Connection was reset, errno 10054”这样的错误<br>可以通过 解除SSL认证 的方式尝试解决 具体的方法如下：<br>在当前文件位置下通过 Git Bash 中输入以下命令：<br>git config –global http.sslVerify “false” </p><p>更多问题可参考”<a href="https://blog.csdn.net/m0_51269961/article/details/123709195">https://blog.csdn.net/m0_51269961/article/details/123709195</a>“<br>*&#x2F;<br><a href="https://benwang717.github.io/">https://benwang717.github.io</a> #访问这个地址可以查看博客</p><p> git clone <a href="https://benwang717.github.io/">https://benwang717.github.io</a> themes&#x2F;yilia  #下载yilia主题到本地</p><p>#修改hexo根目录下的 _config.yml 文件 ： theme: yilia</p><p>hexo c#清理一下<br>hexo g#生成<br>hexo d#部署到远程Github仓库</p><p>或：</p><p>hexo c#清理一下<br>hexo d -g #部署+生成</p><p><a href="https://benwang717.github.io/">https://benwang717.github.io/</a>  #查看博客</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
