<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>创建动态链接库.dll(Dynamic Link Library)</title>
      <link href="/2023/04/03/%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"/>
      <url>/2023/04/03/%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>本篇介绍如何使用qt创建一个动态链接库,并如何使用自己创建的动态库.</p><p><img src="/../images/image-20230803140633332.png" alt="image-20230803140633332"></p><hr><h2 id="创建动态链接库："><a href="#创建动态链接库：" class="headerlink" title="创建动态链接库："></a>创建动态链接库：</h2><p><img src="/../images/image-20230803141250596.png" alt="image-20230803141250596"></p><p><img src="/../images/image-20230803141350915.png" alt="image-20230803141350915"></p><p><img src="/../images/image-20230803141417812.png" alt="image-20230803141417812"></p><p><img src="/../images/image-20230803141433542.png" alt="image-20230803141433542"></p><p><img src="/../images/image-20230803141451031.png" alt="image-20230803141451031"></p><p><img src="/../images/image-20230803141543224.png" alt="image-20230803141543224"></p><p><img src="/../images/image-20230803141559439.png" alt="image-20230803141559439"></p><p>项目创建完成之后可以看到三个文件,这里库函数中的功能函数要写在mydll.h和mydll.cpp中,如果比较复杂可以添加新的.h&#x2F;.cpp, 下面以此为例</p><p><img src="/../images/image-20230803141652147.png" alt="image-20230803141652147"></p><p>首先在mydll.h中声明我们需要封装的功能函数并在cpp中实现并写入功能</p><p><img src="/../images/image-20230803142324755.png" alt="image-20230803142324755"></p><p><img src="/../images/image-20230803142538825.png" alt="image-20230803142538825"></p><p>此时动态库已经编辑完成,保存之后构建项目</p><p><img src="/../images/image-20230803142726500.png" alt="image-20230803142726500"></p><p>构建完成之后找到构建目录,从对应的构建方式下找到对应的.dll文件</p><p><img src="/../images/image-20230803142905635.png" alt="image-20230803142905635"></p><p><img src="/../images/image-20230803142938036.png" alt="image-20230803142938036"></p><p>此时动态链接库文件已经生成完成,接下来讲解如何调用我们生成的动态库</p><h2 id="调用动态链接库"><a href="#调用动态链接库" class="headerlink" title="调用动态链接库:"></a>调用动态链接库:</h2><p>要调用自定义的动态库, 首先创建一个默认的qt项目,这里不再展示创建过程</p><p><img src="/../images/image-20230803143436798.png" alt="image-20230803143436798"></p><p>项目创建完成之后,首先进入项目所在的路径,穿件两个文件夹,分别命名为lib和include, 这里lib文件夹中存放.dll文件, include文件夹中把我们生成动态库文件的项目中的头文件.h放进来. </p><p><img src="/../images/image-20230803143700235.png" alt="image-20230803143700235"></p><p><img src="/../images/image-20230803143811304.png" alt="image-20230803143811304"></p><p><img src="/../images/image-20230803143833559.png" alt="image-20230803143833559"></p><p>完成以上操作之后, 回到QT我们创建的项目, 进入.pro文件, 在文件中添加我们创建的路径信息</p><p><img src="/../images/image-20230803144253959.png" alt="image-20230803144253959"></p><p><img src="/../images/image-20230803144226004.png" alt="image-20230803144226004"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加include文件夹</span></span><br><span class="line">INCLUDEPATH += $$PWD/include</span><br><span class="line"><span class="comment">//添加lib文件夹, 并加入名为&quot;mydll&quot;的.dll文件, 这里需要注意语法-l后追加文件名</span></span><br><span class="line">LIBS += -L$$PWD/lib -lmydll</span><br></pre></td></tr></table></figure><p>以上就完成了动态库的路径配置, 接下里是动态库的调用</p><p><img src="/../images/image-20230803145034953.png" alt="image-20230803145034953"></p><p>完成之后运行项目项目</p><p><img src="/../images/image-20230803145218801.png" alt="image-20230803145218801"></p><p>这里我们就成功的在项目中调用了自建的动态链接库</p>]]></content>
      
      
      
        <tags>
            
            <tag> 动态链接库 </tag>
            
            <tag> .dll </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态链接库.dll(Dynamic Link Library)</title>
      <link href="/2023/03/11/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2023/03/11/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>在一些有特定需求对的项目中可能会用到动态链接库, 如果是标准的动态链接库我们找到它对应的接口调用其功能即可, 而在一些特定的情况下我们可能需要自定义动态链接库. 本篇主要阐释动态链接库的基本概念,后续我会更新如何自定义一个动态链接库文件,以及如何在自己的项目中调用自定义的动态链接库.</p><hr><h2 id="动态链接库："><a href="#动态链接库：" class="headerlink" title="动态链接库："></a>动态链接库：</h2><h3 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h3><p>动态链接库（Dynamic Link Library，DLL）是一种在Windows操作系统中常见的可执行文件格式，用于存储可被应用程序动态加载和使用的代码和数据。与静态链接库不同，动态链接库在程序运行时才会被加载，并且可以被多个应用程序共享。</p><p>以下是动态链接库的一些特点和优势：</p><ol><li><p>动态加载：动态链接库可以在程序运行时通过操作系统的动态链接机制被加载到内存中。这意味着只有在需要使用库中的函数或符号时才会加载，可以减少内存占用和启动时间。</p></li><li><p>共享使用：多个应用程序可以同时使用同一个动态链接库。这样可以避免代码的重复，节省存储空间，并且可以实现代码的统一更新和维护。</p></li><li><p>动态更新：由于动态链接库是独立于应用程序的，因此可以方便地对库进行更新和升级。应用程序无需重新编译和发布，只需要替换库文件即可。</p></li><li><p>模块化设计：动态链接库可以将功能模块化，使得代码更易于组织、维护和复用。通过将相关的功能封装在动态链接库中，可以实现高内聚、低耦合的设计。</p></li><li><p>符号解析：动态链接库中的函数和符号可以被应用程序动态解析和调用。通过获取函数指针或符号地址，应用程序可以直接调用库中的函数，实现与库的交互和功能扩展。</p></li></ol><p>动态链接库在实际应用中有广泛的应用场景，例如插件系统、共享组件、第三方库的使用等。它们提供了一种灵活、高效的方式来扩展和增强应用程序的功能。同时，动态链接库也需要注意版本兼容性、依赖关系等问题，以确保应用程序能够正确加载和使用库。</p><h3 id="包含信息"><a href="#包含信息" class="headerlink" title="包含信息"></a>包含信息</h3><p>动态链接库（Dynamic Link Library，DLL）是一种可被多个程序共享使用的代码和数据的集合。在Windows操作系统中，DLL文件通常包含以下几类信息：</p><ol><li><p>导出函数：DLL文件可以包含一个或多个可供其他程序调用的函数。这些函数被称为导出函数，可以通过函数名来调用。导出函数定义了DLL提供给其他程序的接口。</p></li><li><p>导入函数：DLL文件可以引用其他DLL文件或操作系统提供的函数。这些函数被称为导入函数，可以在DLL文件中使用，但是它们的实现在其他DLL文件或操作系统中。导入函数定义了DLL依赖的接口。</p></li><li><p>数据段：DLL文件可以包含一些静态数据，这些数据可以被多个程序共享。这些数据可以存储全局变量、常量、配置信息等。</p></li><li><p>资源：DLL文件可以包含一些资源，例如图标、位图、字符串等。这些资源可以在程序运行时被其他程序或操作系统使用。</p></li></ol><p>DLL文件的内部信息通常以一种特定的格式进行存储和组织。在Windows操作系统中，DLL文件的格式遵循PE（Portable Executable）格式，这是一种可移植可执行文件的格式。PE格式定义了DLL文件的头部信息、节区信息、导入表、导出表、符号表等。这些信息描述了DLL的结构和内容，使得操作系统和其他程序能够正确加载和使用DLL文件中的代码和数据。</p><p>需要注意的是，DLL文件的具体格式和内容可能会因不同的操作系统或编程语言而有所差异，上述信息仅是一般情况下的常见特征。</p><h3 id="生成步骤"><a href="#生成步骤" class="headerlink" title="生成步骤"></a>生成步骤</h3><p>要生成一个动态链接库（DLL），你可以按照以下步骤进行操作：</p><ol><li><p>选择编程语言：首先，选择你熟悉的编程语言。常用的编程语言如C&#x2F;C++、C#、Java等都提供了生成DLL的支持。</p></li><li><p>编写代码：使用你选择的编程语言编写DLL代码。在代码中定义导出函数（可供其他程序调用的函数）和其他需要共享的数据。</p></li><li><p>声明导出函数：在DLL代码中，需要使用适当的语法和关键字来声明导出函数。这可以告诉编译器将这些函数作为DLL的导出函数进行处理。</p></li><li><p>编译代码：使用编译器将DLL代码编译为二进制文件。编译时，应该指定生成动态链接库的选项，以确保生成正确的文件类型。</p></li><li><p>链接库文件：将编译生成的二进制文件链接为DLL文件。这通常需要使用特定的工具或命令来完成。链接过程将把DLL文件与所需的运行时库和其他依赖项进行关联。</p></li><li><p>测试和调试：编译和链接成功后，你可以对生成的DLL文件进行测试和调试。确保导出函数的功能正确，并且DLL在其他程序中能够正常加载和使用。</p></li></ol><p>需要注意的是，生成DLL的具体步骤可能因所使用的编程语言和开发环境而有所差异。建议参考相应编程语言的文档或教程，以了解特定语言和工具的详细操作步骤。</p><p>以下是使用C++语言生成动态链接库（DLL）的基本示例：</p><ol><li><p>创建一个新的C++源文件，例如example.cpp。</p></li><li><p>在example.cpp中编写DLL的代码，包括导出函数和其他需要共享的数据。以下是一个简单的示例：</p></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function"><span class="type">int</span> <span class="title">AddNumbers</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他需要共享的数据</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="type">int</span> sharedData = <span class="number">42</span>;</span><br></pre></td></tr></table></figure><p>在此示例中，AddNumbers函数是一个导出函数，可以被其他程序调用。sharedData是一个共享的整数变量。</p><ol start="3"><li>使用C++编译器（如g++或Visual C++）编译源代码，并将其生成为DLL文件。以下是使用g++编译器的示例命令行：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ -shared -o example.dll example.cpp</span><br></pre></td></tr></table></figure><p>此命令将源文件example.cpp编译为名为example.dll的动态链接库文件。</p><ol start="4"><li>编译成功后，将生成的example.dll文件与所需的运行时库和其他依赖项一起使用。你可以在其他C++程序中加载和调用该DLL提供的函数，或让其他语言的程序调用。</li></ol><p>请注意，在不同的操作系统和编译环境下，生成DLL的具体命令和选项可能会有所不同。建议参考你所使用的编译器和开发环境的文档，以了解相应的生成DLL方法和选项。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 动态链接库 </tag>
            
            <tag> .dll </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程_join()</title>
      <link href="/2023/02/15/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B_join()/"/>
      <url>/2023/02/15/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B_join()/</url>
      
        <content type="html"><![CDATA[<h2 id="join"><a href="#join" class="headerlink" title="join()"></a><strong>join()</strong></h2><p>​假设存在一个主线程中有一个子线程，主线程执行周期为500ms，而子线程中的业务逻辑稍微复杂一点，执行所用的时间周期更长大概需要800ms。那么在中情况下，如果任凭事情发展，最终的结果会是，子线程的业务逻辑还未执行完毕就随着主线程的结束而直接终止了。为了防止这种情况的发生就有了join()函数。</p><p>​使用方法：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> num, string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;num: &quot;</span> </span><br><span class="line">             &lt;&lt; num &lt;&lt; <span class="string">&quot;, str: &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">download1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 模拟下载, 总共耗时500ms，阻塞线程500ms</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程1: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">download2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 模拟下载, 总共耗时300ms，阻塞线程300ms</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">300</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程2: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;....主线程来了....&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* cout &lt;&lt; &quot;主线程的线程ID: &quot; &lt;&lt; this_thread::get_id() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    thread t(func, 123, &quot;abc&quot;);</span></span><br><span class="line"><span class="comment">    // 需要注明的是，thread声明的对象应含有这种形式：</span></span><br><span class="line"><span class="comment">    // 首先是函数的名称，然后依次传入该函数对应类型的函数参数    </span></span><br><span class="line"><span class="comment">    thread t1(func1);</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &quot;线程t 的线程ID: &quot; &lt;&lt; t.get_id() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &quot;线程t1的线程ID: &quot; &lt;&lt; t1.get_id() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    t.join();</span></span><br><span class="line"><span class="comment">    t1.join();*/</span></span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(download1)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(download2)</span></span>;</span><br><span class="line">    <span class="comment">// 阻塞主线程，等待所有子线程任务执行完毕再继续向下执行</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">doSomething</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如代码中，通过声明的类的对象调用join()函数实现线程阻塞。输出的结果为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子线程2: 72540</span></span><br><span class="line"><span class="comment">// 子线程1: 79776</span></span><br><span class="line"><span class="comment">// ....主线程来了....</span></span><br></pre></td></tr></table></figure><p>通过输出结果可以看出，主线程是在子线程调用完毕之后再调用的，说明主线程已经被阻塞执行，确保了子线程的完整运行。</p><p><u>需要注意的是：在阻塞线程的时候，一定要注意我们阻塞的是哪个线程，线程在哪个线程被执行，就阻塞哪个线程。</u></p><p>以上(*￣︶￣)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> C++11 </tag>
            
            <tag> C++ </tag>
            
            <tag> join() </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程_datach()</title>
      <link href="/2023/02/13/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B_detach()/"/>
      <url>/2023/02/13/C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B_detach()/</url>
      
        <content type="html"><![CDATA[<h2 id="detach"><a href="#detach" class="headerlink" title="detach()"></a><strong>detach()</strong></h2><p>​“从前一户人家的孩子非常叛逆，家里人已经管不了他了，他离家出走开始了自己独立的生活，后来家里触犯了律法，被满门抄斩，这个离家出走的孩子也依然会被株连。”</p><p>​存在某一种情况，我们需要单独执行某一个线程下的子线程，而且需要在执行这个子线程时，不会影响原有的线程。这个时候就需要用到线程分离函数detach()</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> num, string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;num: &quot;</span> </span><br><span class="line">             &lt;&lt; num &lt;&lt; <span class="string">&quot;, str: &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">download1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 模拟下载, 总共耗时500ms，阻塞线程500ms</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程1: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">download2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 模拟下载, 总共耗时300ms，阻塞线程300ms</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">300</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程2: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;....主线程来了....&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程的线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func, <span class="number">123</span>, <span class="string">&quot;abc&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 需要注明的是，thread声明的对象应含有这种形式：</span></span><br><span class="line">    <span class="comment">// 首先是函数的名称，然后依次传入该函数对应类型的函数参数    </span></span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程t 的线程ID: &quot;</span> &lt;&lt; t.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程t1的线程ID: &quot;</span> &lt;&lt; t1.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">    t1.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="comment">// 让主线程休眠，等待子线程执行结束</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">second</span>(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：线程分离不会阻塞线程，子主线程分离之后，在主线程中就不能再对该子线程进行任何控制了，比如：通过 join () 阻塞主线程等待子线程中的任务执行完毕，或者调用 get_id () 获取子线程的线程 ID等。有利就有弊，鱼和熊掌不可兼得，建议使用 join ()。</p><p>以上(*￣︶￣)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> detach() </tag>
            
            <tag> C++11 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Qt中.pri文件</title>
      <link href="/2023/01/17/%E5%85%B3%E4%BA%8EQt%E4%B8%AD.pri%E6%96%87%E4%BB%B6/"/>
      <url>/2023/01/17/%E5%85%B3%E4%BA%8EQt%E4%B8%AD.pri%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>​通过Qt创建的项目中，例如通常情况下的小项目，较少用到.pri文件。但是在中型或大型项目当中，需要把项目中的各个功能模块化，分隔开独立开发。这个时候就需要用到.pri文件取分支项目。以下是.pri的创建流程：</p><ol><li><p>首先在创建好的项目中右键.pro文件→在Explorer中打开，打开项目所在路径</p></li><li><p>在项目所在的路径中新建一个文件夹并命名demo</p></li><li><p>在文件夹中新建txt文件，并重命名为demo.pri</p></li><li><p>回到Qt，在Qt界面中的pro文件中添加</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">include</span>($$PWD/demo/demo.pri)</span><br><span class="line"><span class="comment">//$$：环境变量名</span></span><br></pre></td></tr></table></figure></li><li><p>添加完成后保存，等待一会儿就可以看到，项目中新添加了新的demo类目，其中存在demo.pri文件</p></li><li><p>这样分化的类目的基本雏形就存在了，接下来是在这个类目中添加新的.h&#x2F;.cpp和ui文件(注：并非所有的类目都需要ui文件，这里会分开说明)</p></li><li><p>a.如果不需要ui文件：右击新添加的类目，从选项中选择添加新文件，选择“C&#x2F;C++”，然后按照正常的项目创建流程创建即可；</p><p>b.如果需要ui文件：依然是单击右键，选择添加新文件，选择”Qt”，在这一类目中选择”Qt 设计器界面类”，然后按照正常流程创建即可</p></li><li><p>以上这两种方式在创建完成时，会在.pri文件中直接生成引用源，不需要再次声明</p><p>大概流程就是这样</p><p>以上(*￣︶￣)</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Qt </tag>
            
            <tag> .pri </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Qt中.pro文件</title>
      <link href="/2023/01/17/%E5%85%B3%E4%BA%8EQt%E4%B8%AD.pro%E6%96%87%E4%BB%B6/"/>
      <url>/2023/01/17/%E5%85%B3%E4%BA%8EQt%E4%B8%AD.pro%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>本文主要列举说明在qt中新建项目生成的pro文件中，所涉及到的一些类目，可能不全，后续会再补充。</p><ol><li>QT +&#x3D; 是添加QT项目需要的模块 QT-&#x3D;是排除或者移除某个模块</li><li>HEADERS：.h文件</li><li>SOURCES：.cpp文件</li><li>FORMS：指定需要uic处理的ui文件</li><li>RESOURCES：指定需要rcc处理的qrc文件</li><li>DEFINES：指定预定义预处理器符号</li><li>INCLUDEPATH：指定C++编译器搜索头文件路径</li><li>LIBS：指定工程要链接的库</li><li>CONFIG：指定工程配置和编译参数</li><li>QT：指定工程所要使用的Qt模块</li><li>VERSION：指定目标库版本号</li><li>TARGET：指定可执行文件或库的基本文件名，默认为当前目录名</li><li>DESTDIR：指定可执行文件放置的目录</li><li>DLLDESTDIR：指定目标库文件放置的目录</li><li>RC_ICONS：添加icon</li><li>include:引入头文件或者pri文件</li><li>PWD:指的是当前正在解析的.pro文件的目录的完整路径</li><li>OUT_PWD:指的是qmake生成的Makefile的目录的完整路径</li><li>message:pro文件里面的打印输出</li><li>win32：条件编译</li></ol><h3 id="其中几个比较重要的说明："><a href="#其中几个比较重要的说明：" class="headerlink" title="其中几个比较重要的说明："></a>其中几个比较重要的说明：</h3><p>LIBS：指定工程要链接的库</p><p>LIBS 相对来说是比较重要的，因为在一些开发当中经常需要添加第三方库。这个时候就需要用LIBS来引入第三方库到工程中</p><p>LIBS的格式：    LIBS +&#x3D; -L路径 库名字</p><p>eg:            LIBS +&#x3D; -L$$PWD&#x2F;Demo_Pri&#x2F; -lvisa32d<br>#######################################################################################<br>-L :表示Local 即库的位置<br>-l :表示库本身 即库的名称<br>[注意不需要加dll&#x2F;so等后缀(QT跨平台比较强，后缀名为根据平台自动选择)]<br>####################################################################################### </p><p>自动拷贝<a href="https://so.csdn.net/so/search?q=dll%E6%96%87%E4%BB%B6&spm=1001.2101.3001.7020">dll文件</a>的方法：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">法<span class="number">1</span>：</span><br><span class="line">#利用cpoys 这个命令</span><br><span class="line">cp_kk.files += \</span><br><span class="line">            chartdir50.dll</span><br><span class="line">cp_kk.path  += $$OUT_PWD/release</span><br><span class="line">COPIES +=  cp_kk</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">法<span class="number">2</span>：</span><br><span class="line">#QMAKE_SUBSTITUTES</span><br><span class="line">DLL.input =  chartdir50.dll</span><br><span class="line">DLL.output = $$OUT_PWD/release/chartdir50.dll</span><br><span class="line">DLL.CONFIG = verbatim # 完全复制</span><br><span class="line">QMAKE_SUBSTITUTES += DLL</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Qt </tag>
            
            <tag> .pro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物联网智能家居-智能开关</title>
      <link href="/2022/12/25/%E7%89%A9%E8%81%94%E7%BD%91%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85-%E6%99%BA%E8%83%BD%E5%BC%80%E5%85%B3/"/>
      <url>/2022/12/25/%E7%89%A9%E8%81%94%E7%BD%91%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85-%E6%99%BA%E8%83%BD%E5%BC%80%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>这几天阳性在家，这个智能开关是小半个多月之前就计划制作了。本身并不是很难的东西。不过中间买错了东西，耽误了点时间，刚好赶上休息时间东西到了，也就把东西做出来了。</p><hr><h2 id="首先是硬件材料的准备："><a href="#首先是硬件材料的准备：" class="headerlink" title="首先是硬件材料的准备："></a>首先是硬件材料的准备：</h2><p>基于ESP8266的ESP-01、Relay模块、CH340C</p><p>就这三个东西，在拼多多上直接买都有，一共下来大概不到20块钱</p><hr><h2 id="接下来是环境的配置："><a href="#接下来是环境的配置：" class="headerlink" title="接下来是环境的配置："></a>接下来是环境的配置：</h2><p>1.首先是安装Arduino(这个没什么难度，注意自己把安装的分区分好，别放C盘，路径上最好是别有中文和空格)；</p><p>2.在手机上下载一个blinker，这个是人家做好的物联网app，就直接拿来用了，以后还是打算自己写一个哈哈。</p><p>3.只安装好Arduino还不行，需要在软件中补充开发板信息，找到<u>开发板管理器</u>，然后搜索ESP8266，很有可能找不到，这个时候你需要首先在<u>首选项</u>里的<u>其他开发板管理器地址</u>中添加<a href="http://arduino.esp8266.com/stable/package_esp8266com_index.json%EF%BC%8C%E7%84%B6%E5%90%8E%E4%BF%9D%E5%AD%98%E4%B8%80%E4%B8%8B%EF%BC%8C%E5%86%8D%E6%B7%BB%E5%8A%A0%E5%BC%80%E5%8F%91%E6%9D%BF%E8%AF%95%E8%AF%95%E3%80%82%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E9%9D%9E%E5%B8%B8%E6%85%A2%E3%80%82%E5%A6%82%E6%9E%9C%E5%AB%8C%E6%85%A2%E5%8F%AF%E4%BB%A5%E5%8E%BBGit%E4%B8%8A%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%EF%BC%8C%E6%94%BE%E5%9C%A8%E7%9B%AE%E6%A0%87%E7%9B%AE%E5%BD%95%E9%87%8C%E5%8D%B3%E5%8F%AF%E3%80%82">http://arduino.esp8266.com/stable/package_esp8266com_index.json，然后保存一下，再添加开发板试试。这个过程非常慢。如果嫌慢可以去Git上直接下载，放在目标目录里即可。</a></p><p>4.完成以上步骤后，还差一个步骤。我们在使用blinker这个app的时候，在烧录的代码里需要用到&lt;Blinker.h&gt;的头文件的库函数。这个也需要我们在Arduino中自己搜索添加。在管理库这个选项中，搜索blinker，有两个，我都下载了哈哈，反正没多大。</p><p>5.接下来就可以烧录了。直接上代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BLINKER_WIFI</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Blinker.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> auth[] = <span class="string">&quot;75*****27&quot;</span>; <span class="comment">//点灯科技设备KEY</span></span><br><span class="line"><span class="type">char</span> ssid[] = <span class="string">&quot;A**X&quot;</span>;  <span class="comment">//WIFI名称-只支持2.4G</span></span><br><span class="line"><span class="type">char</span> pswd[] = <span class="string">&quot;B******6&quot;</span>; <span class="comment">//WIFI密码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bt1 5</span></span><br><span class="line"><span class="comment">// #define bt2 4</span></span><br><span class="line"><span class="comment">// #define bt3 0</span></span><br><span class="line"><span class="comment">// #define bt4 2</span></span><br><span class="line"><span class="comment">// 新建组件对象</span></span><br><span class="line"><span class="function">BlinkerButton <span class="title">Button1</span><span class="params">(<span class="string">&quot;btn1&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按下按键即会执行该函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">button1_callback</span><span class="params">(<span class="type">const</span> String &amp; state)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">BLINKER_LOG</span>(<span class="string">&quot;get button state: &quot;</span>, state);</span><br><span class="line">  <span class="keyword">if</span> (state == <span class="string">&quot;on&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">digitalWrite</span>(bt1, LOW);</span><br><span class="line">    <span class="comment">// 反馈开关状态</span></span><br><span class="line">    Button1.<span class="built_in">print</span>(<span class="string">&quot;on&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="string">&quot;off&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">digitalWrite</span>(bt1, HIGH);</span><br><span class="line">    <span class="comment">// 反馈开关状态</span></span><br><span class="line">    Button1.<span class="built_in">print</span>(<span class="string">&quot;off&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化串口</span></span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line">  <span class="comment">// 初始化有LED的IO</span></span><br><span class="line">  <span class="built_in">pinMode</span>(bt1, OUTPUT);</span><br><span class="line">  <span class="built_in">digitalWrite</span>(bt1, HIGH);</span><br><span class="line">  <span class="comment">// 初始化blinker</span></span><br><span class="line">  Blinker.<span class="built_in">begin</span>(auth, ssid, pswd);</span><br><span class="line">  Button1.<span class="built_in">attach</span>(button1_callback);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Blinker.<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就基本完成了，接上自己家里的灯就可以使用了。之后我会再补充和完善一些功能。最近写的还有不少笔记没来得及发出来，最近一两周看如果有时间的话我就发出来。</p>]]></content>
      
      
      
        <tags>
            
            <tag> IoT </tag>
            
            <tag> ESP8266 </tag>
            
            <tag> Arduino </tag>
            
            <tag> blinker </tag>
            
            <tag> 智能家居 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QPushButton/QLabel鼠标悬浮（划过， hover）、选中（单击， pressed）状态下更换图标样式</title>
      <link href="/2022/12/03/QPushButtonQLabel%E9%BC%A0%E6%A0%87%E6%82%AC%E6%B5%AE(%E5%88%92%E8%BF%87%EF%BC%8C%20hover)%E9%80%89%E4%B8%AD(%E5%8D%95%E5%87%BB,pressed)%E7%8A%B6%E6%80%81%E4%B8%8B%E6%9B%B4%E6%8D%A2%E5%9B%BE%E6%A0%87%E6%A0%B7%E5%BC%8F/"/>
      <url>/2022/12/03/QPushButtonQLabel%E9%BC%A0%E6%A0%87%E6%82%AC%E6%B5%AE(%E5%88%92%E8%BF%87%EF%BC%8C%20hover)%E9%80%89%E4%B8%AD(%E5%8D%95%E5%87%BB,pressed)%E7%8A%B6%E6%80%81%E4%B8%8B%E6%9B%B4%E6%8D%A2%E5%9B%BE%E6%A0%87%E6%A0%B7%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>有三种方式：1.样式表2.event()3.evenfilter()</p><ol><li><h2 id="样式表"><a href="#样式表" class="headerlink" title="样式表"></a>样式表</h2><p>第一种方法：在样式表中设置 border-image（在网上看到有人使用 background-image 的，不推荐，因为那样的话图标大小是不会自动缩放的，有兴趣的可以试一下）。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QPushButton *button1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line">button1-&gt;<span class="built_in">setFixedSize</span>(<span class="number">30</span>, <span class="number">30</span>);</span><br><span class="line">button1-&gt;<span class="built_in">setFlat</span>(<span class="literal">true</span>);</span><br><span class="line">button1-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QPushButton&#123;border-image:url(:/listBar_Icon/add.png);&#125;&quot;</span></span><br><span class="line">                       <span class="string">&quot;QPushButton:hover&#123;border-image:url(:/listBar_Icon/add_hover.png);&#125;&quot;</span></span><br><span class="line">                       <span class="string">&quot;QPushButton:pressed&#123;border-image:url(:/listBar_Icon/add_pressed.png);&#125;&quot;</span></span><br><span class="line">                       );</span><br></pre></td></tr></table></figure><p>优点 ：简单方便。<br>缺点 : border-image 会随着 QPushButton 的大小尺寸变化（图标会填充整个按钮）。上面的例子中按钮形状和图标素材都是正方形的，所以效果不错。如果 QPushButton 只显示图标的话用这种方法比较好，如果需要添加文字而导致按钮形状和素材不同，这种方法则不可取。</p></li><li><h2 id="event"><a href="#event" class="headerlink" title="event()"></a>event()</h2><p>第二种方法：继承 QPushButton，重写 event 事件。效果和第一个 gif 相同。</p><p>MyPushButton.h</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPushButton</span> : <span class="keyword">public</span> QPushButton</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyPushButton</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setUpIcon</span><span class="params">(<span class="type">const</span> QIcon &amp;icon, <span class="type">const</span> QIcon &amp;icon_hover, <span class="type">const</span> QIcon &amp;icon_pressed)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">event</span><span class="params">(QEvent *event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QIcon Img, Img_hover, Img_pressed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>MyPushButton.c</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyPushButton::<span class="built_in">MyPushButton</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QPushButton</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPushButton::setUpIcon</span><span class="params">(<span class="type">const</span> QIcon &amp;icon, <span class="type">const</span> QIcon &amp;icon_hover, <span class="type">const</span> QIcon &amp;icon_pressed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Img = icon;</span><br><span class="line">    Img_hover = icon_hover;</span><br><span class="line">    Img_pressed = icon_pressed;</span><br><span class="line">    <span class="built_in">setIcon</span>(Img);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyPushButton::event</span><span class="params">(QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event-&gt;<span class="built_in">type</span>()) &#123;</span><br><span class="line">    <span class="keyword">case</span> QEvent::Enter:</span><br><span class="line">        <span class="built_in">setIcon</span>(Img_hover);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QEvent::Leave:</span><br><span class="line">        <span class="built_in">setIcon</span>(Img);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QEvent::MouseButtonPress:</span><br><span class="line">        <span class="built_in">setIcon</span>(Img_pressed);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QEvent::MouseButtonRelease:</span><br><span class="line">        <span class="built_in">setIcon</span>(Img_hover);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QPushButton::<span class="built_in">event</span>(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 MyPushButton</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyPushButton *button2 = <span class="keyword">new</span> <span class="built_in">MyPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line">button2-&gt;<span class="built_in">setFixedSize</span>(<span class="number">60</span>, <span class="number">30</span>);</span><br><span class="line">button2-&gt;<span class="built_in">setFlat</span>(<span class="literal">true</span>);</span><br><span class="line">button2-&gt;<span class="built_in">setUpIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/listBar_Icon/add.png&quot;</span>), <span class="built_in">QIcon</span>(<span class="string">&quot;:/listBar_Icon/add_hover.png&quot;</span>), <span class="built_in">QIcon</span>(<span class="string">&quot;:/listBar_Icon/add_pressed.png&quot;</span>));</span><br><span class="line">button2-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QPushButton&#123;border:0px solid rgba(0, 0, 0, 255);&#125;&quot;</span>);</span><br><span class="line">button2-&gt;<span class="built_in">setIconSize</span>(<span class="built_in">QSize</span>(<span class="number">30</span>, <span class="number">30</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>优点 ：图标显示效果不会受到按钮尺寸影响，只由setIconSize(QSize)控制。</li><li>缺点 ：有点复杂</li></ul></li><li><h2 id="evenfilter"><a href="#evenfilter" class="headerlink" title="evenfilter()"></a>evenfilter()</h2><p>第三种方法：原理及优缺点和第二种方法相同，只是不需要继承 QPushButton，而是重写主窗口的事件过滤器。</p><p>主窗口.h：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">test</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPushButton *button3 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initUi</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *obj, QEvent *event)</span> <span class="keyword">override</span></span>;  <span class="comment">//事件过滤</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主窗口.c：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">test::<span class="built_in">test</span>(QWidget *parent) : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">initUi</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test::initUi</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    button3 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line">    button3-&gt;<span class="built_in">setFixedSize</span>(<span class="number">30</span>, <span class="number">30</span>);</span><br><span class="line">    button3-&gt;<span class="built_in">setFlat</span>(<span class="literal">true</span>);</span><br><span class="line">    button3-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/listBar_Icon/add.png&quot;</span>));</span><br><span class="line">    button3-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QPushButton&#123;border:0px solid rgba(0, 0, 0, 255);&#125;&quot;</span>);</span><br><span class="line">    button3-&gt;<span class="built_in">setIconSize</span>(<span class="built_in">QSize</span>(<span class="number">30</span>, <span class="number">30</span>));</span><br><span class="line">    button3-&gt;<span class="built_in">installEventFilter</span>(<span class="keyword">this</span>);  <span class="comment">//安装事件过滤器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">test::eventFilter</span><span class="params">(QObject *obj, QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event-&gt;<span class="built_in">type</span>()) &#123;</span><br><span class="line">    <span class="keyword">case</span> QEvent::HoverEnter:</span><br><span class="line">        <span class="keyword">if</span>(obj == button3)</span><br><span class="line">            button3-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/listBar_Icon/add_hover.png&quot;</span>));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QEvent::HoverLeave:</span><br><span class="line">        <span class="keyword">if</span>(obj == button3)</span><br><span class="line">            button3-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/listBar_Icon/add.png&quot;</span>));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QEvent::MouseButtonPress:</span><br><span class="line">        <span class="keyword">if</span>(obj == button3)</span><br><span class="line">            button3-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/listBar_Icon/add_pressed.png&quot;</span>));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QEvent::MouseButtonRelease:</span><br><span class="line">        <span class="keyword">if</span>(obj == button3)</span><br><span class="line">            button3-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/listBar_Icon/add_hover.png&quot;</span>));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QWidget::<span class="built_in">eventFilter</span>(obj, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>如果需要在按钮中添加文字，那么只能使用后面两种方法。 QLabel和QPushButton差不多，不再赘述。</p><p>以上，(*￣︶￣)</p>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> QPushButton </tag>
            
            <tag> QLabel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈你对拷贝构造函数和赋值运算符的认识</title>
      <link href="/2022/11/23/%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E8%AE%A4%E8%AF%86/"/>
      <url>/2022/11/23/%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E8%AE%A4%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>我们在通过类定义一个对象</p><p>比如:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">stu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">stu</span>(<span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">m_age = a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过如下方式产生一个拷贝构造函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">stu <span class="title">p1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">stu <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br></pre></td></tr></table></figure><p>这样，p2就是通过编译器为我们自动进行了一次浅拷贝</p><p>[待补充…]</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
            <tag> 面试题 </tag>
            
            <tag> 拷贝构造函数 </tag>
            
            <tag> 函数重载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>static关键字在C语言和C++中的使用及区别</title>
      <link href="/2022/11/23/static%E5%85%B3%E9%94%AE%E5%AD%97%E5%9C%A8C%E8%AF%AD%E8%A8%80%E5%92%8CC++%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/11/23/static%E5%85%B3%E9%94%AE%E5%AD%97%E5%9C%A8C%E8%AF%AD%E8%A8%80%E5%92%8CC++%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="一、总述"><a href="#一、总述" class="headerlink" title="一、总述"></a>一、总述</h2><p>由于C++兼容C语言，所以<strong>static在C语言中的用法对于C++是同样适用的</strong>。两者的不同就是C++中多出来的特性，而这些特性与C++面线对象的特性有关。</p><h2 id="二、static在C语言中的作用（C-通用）"><a href="#二、static在C语言中的作用（C-通用）" class="headerlink" title="二、static在C语言中的作用（C++通用）"></a>二、static在C语言中的作用（C++通用）</h2><h3 id="1、修饰变量"><a href="#1、修饰变量" class="headerlink" title="1、修饰变量"></a>1、修饰变量</h3><h4 id="a、修饰全局变量（全局变量与静态全局变量的对比）"><a href="#a、修饰全局变量（全局变量与静态全局变量的对比）" class="headerlink" title="a、修饰全局变量（全局变量与静态全局变量的对比）"></a>a、修饰全局变量（全局变量与静态全局变量的对比）</h4><p>​修饰全局变量：作用域仅限于变量被定义的文件中，其他文件即使用extern声明也无法直接使用此变量，extern用法详见这里。（可以间接访问，即通过本文件的非static函数返回static变量的值，类似于C++类中的private变量外界没有权限访问，但是可以通过public函数返回private变量的值）。<br>​对比：全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同，且都只初始化一次，但静态全局变量对其他文件不可见，全局变量是可见的。<br>​总结：把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。  </p><h4 id="b、修饰局部变量"><a href="#b、修饰局部变量" class="headerlink" title="b、修饰局部变量"></a>b、修饰局部变量</h4><p>​修饰局部变量：在函数内定义的局部变量被修饰，可以延长变生命周期，但是作用域不变，只初始化一次。<br>​对比：普通局部变量定义后，出了作用域就会被释放，静态局部变量生命周期到程序结束才结束。<br>​总结：把局部变量改变为静态变量后是改变了它的存储方式，让静态局部变量出了作用域依然存在，到程序结束，生命周期才结束。</p><h3 id="2、修饰函数"><a href="#2、修饰函数" class="headerlink" title="2、修饰函数"></a>2、修饰函数</h3><p>和全局变量一样，函数的定义和声明默认情况下是extern的，但静态函数只是在声明它的文件当中可见，不能被其他文件所用。</p><h2 id="三、static在C-中的作用"><a href="#三、static在C-中的作用" class="headerlink" title="三、static在C++中的作用"></a>三、static在C++中的作用</h2><p>C+ +重用了这个关键字，并赋予它与前面不同的含义：表示属于一个类而不是属于此类的任何特定对象的变量和函数。</p><h3 id="1、静态数据成员"><a href="#1、静态数据成员" class="headerlink" title="1、静态数据成员"></a>1、静态数据成员</h3><p>静态数据成员是属于整个类的，而不是属于某个对象。即不管实例多少个对象，它们都公用一个静态数据成员（如：使用静态数据成员统计类已经实例化了多少对象）。</p><p>在c++中，普通数据成员在构造函数的函数体或初始化表中初始化；常量数据成员(const int a )必须在构造函数的初始化表中初始化（const对象或引用只能初始化但是不能赋值。构造函数的函数体内只能做赋值而不是初始化）；而静态数据成员(static int b )则必须在类外初始化（int 类名::b&#x3D;100），这是因为静态数据成员不属于任何一个对象，而是属于整个类的。</p><h3 id="2、静态成员函数"><a href="#2、静态成员函数" class="headerlink" title="2、静态成员函数"></a>2、静态成员函数</h3><p>静态成员函数是属于整个类的，而不是属于某个对象。静态成员函数可以被该类的所有对象直接访问；静态成员函数本身只能访问静态成员，不可以访问非静态成员。</p><h2 id="四、常见面试题–为什么static变量值只初始化一次？"><a href="#四、常见面试题–为什么static变量值只初始化一次？" class="headerlink" title="四、常见面试题–为什么static变量值只初始化一次？"></a>四、常见面试题–为什么static变量值只初始化一次？</h2><p>对于所有的对象（不仅仅是静态对象），初始化都只有一次，初始化后，一直都没有被销毁&#x2F;释放，都会保存在内存区域中，所以不会再次初始化。存放在静态区的变量的生命周期与整个程序“同生死、共存亡”，所以它只需初始化一次。而auto变量，即自动变量，由于它存放在栈区，一旦函数调用结束，就会立刻被销毁。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> static </tag>
            
            <tag> C </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深拷贝和浅拷贝</title>
      <link href="/2022/11/11/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2022/11/11/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Team</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;默认函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Team</span>(<span class="type">int</span> a,<span class="type">int</span> b) 含参的构造函数</span><br><span class="line">&#123;</span><br><span class="line">m_A = a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Team</span>(<span class="type">const</span> Team &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;复制函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Team</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> m_A;</span><br></pre></td></tr></table></figure><p>如上面的代码。当我们在调用一个有参的构造函数声明变量  c1 并对其赋值时，我们可以通过重新使用该类声明一个新的变量 c2 ，在赋值的 ( ) 中，将已经赋值过的变量 c1 填入，即 c2(c1)。通过这样的方式 ，我们可以得到一个赋值好的 c2 变量。其中 c2 中的赋值和 c1 是相同的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Team c1(18);//含参的构造函数</span><br><span class="line">cout &lt;&lt; c1 &lt;&lt; endl;</span><br><span class="line">Team c2(c1);</span><br><span class="line">cout &lt;&lt; c2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>以上，我们是通过编译器自动生成了一次对有参函数变量的浅拷贝。</p><p>但是，有时候我们会遇到一些问题。</p><hr><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>首先要知道，堆区：由<strong>程序员</strong>分配释放，若程序员不释放，程序结束后由操作系统回收（运行期间你不管，它就不释放。运行结束就给他回收掉）</p><p>在C++中主要利用<strong>new</strong>在堆区开辟内存</p><p>回到刚刚的代码。可以看到，在Team这个类当中，只有一组参数，那就是 int m_A；m_A是整形变量。那么如果我们的参数中含有指针变量呢？如果含有指针变量，我们的函数还可以按照刚刚浅拷贝那样，由编译器即可自动完成拷贝吗？</p><p>实际上是行不通的。我们需要从浅拷贝的机制来分析。</p><p>在编译器中简单的套用有参变量去传递参数的值的时候(浅拷贝)，实质上就是一种值的传递。而当我们类中的参数含有指针变量，且指针的变量是在堆区开辟的空间，且我们选择手动在最后类的析构函数中释放这段开辟的空间的时候，编译器就会报错。这是为什么？</p><p>首先这也是一种值的传递没有错，但是这个值的传递是对于指针变量来说的，对于普通变量，值的传递就是变量中存储的值的传递。但指针就比较特殊了，指针中存储的“值”，实际上就是地址。这个地址中也存储着值。而这个地址中所存储的值，才是我们需要拷贝，需要传递的值。*(其实说到底还是指针的那些概念)</p><p>所以很明显，问题出在了析构那里。正因为我们选择了在析构函数中手动的释放堆区开辟的空间。所以我们进行了两次析构函数的调用，但其实早在第一次的时候，由于堆区的空间被释放，类中的指针成员所指向的地址和地址里的内容就已经被释放了。那么我们在第二次拷贝参数的时候，就会遇到<strong>堆区的内存被重复释放</strong>这种情况。一旦出现这种情况，编译器会判定为非法操作，自然也就报错了。那么应该如何处理呢？</p><p>以上的拷贝操作实际上是由编译器自动完成的，为了防止堆区的空间被重复释放，我们需要自己定义一个拷贝构造函数就可以解决。</p><p>首先，我们需要在堆区重新申请一块儿内存。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Team</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Team</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;默认函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Team</span>(<span class="type">int</span> a,<span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">m_A = a;</span><br><span class="line">p = <span class="keyword">new</span> <span class="built_in">int</span>(b);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Team</span>(<span class="type">const</span> Team &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;复制函数&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译器默认的实现方式(浅拷贝)</span></span><br><span class="line"><span class="comment">//m_A = a.m_A;</span></span><br><span class="line"><span class="comment">//p = a.p;</span></span><br><span class="line"></span><br><span class="line">        p = <span class="keyword">new</span> <span class="built_in">int</span>(*a.p);<span class="comment">//在堆区重新申请一块儿内存(深拷贝)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Team</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Team <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">160</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; *c1.p &lt;&lt; endl;</span><br><span class="line"><span class="function">Team <span class="title">c2</span><span class="params">(c1)</span></span>;</span><br><span class="line">cout &lt;&lt; *c2.p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 深拷贝 </tag>
            
            <tag> 浅拷贝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建</title>
      <link href="/2022/10/22/hexo%20%E6%90%AD%E5%BB%BA/"/>
      <url>/2022/10/22/hexo%20%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>—#安装git<br>git工具在外网直接下载非常慢，需要在镜像环境中下载<br>如果电脑上有360，可以通过360的软件软件安装管家搜索git，可直接下载</p><p>—#安装Nodejs<br>node -v#查看node版本<br>npm -v#查看npm版本<br>npm install -g cnpm –registry&#x3D;<a href="http://registry.npm.taobao.org/">http://registry.npm.taobao.org</a>#安装淘宝的cnpm 管理器<br>cnpm -v#查看cnpm版本<br>cnpm install -g hexo-cli    #安装hexo框架<br>hexo -v#查看hexo版本<br>mkdir blog#创建blog目录<br>cd blog #进入blog目录<br>sudo hexo init #生成博客 初始化博客<br>hexo s#启动本地博客服务<br><a href="http://localhost:4000/">http://localhost:4000/</a>#本地访问地址<br>hexo n “我的第一篇文章” #创建新的文章<br>#返回blog目录<br>hexo clean #清理<br>hexo g #生成<br>#Github创建一个新的仓库 YourGithubName.github.io</p><h2 id="cnpm-install-–save-hexo-deployer-git-在blog目录下安装git部署插件"><a href="#cnpm-install-–save-hexo-deployer-git-在blog目录下安装git部署插件" class="headerlink" title="cnpm install –save hexo-deployer-git #在blog目录下安装git部署插件"></a>cnpm install –save hexo-deployer-git #在blog目录下安装git部署插件</h2><h2 id="配置-config-yml"><a href="#配置-config-yml" class="headerlink" title="#配置_config.yml "></a>#配置_config.yml </h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:<span class="comment">//hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.这里需要注意在Windows环境下type后边有一个&#x27;&#x27;符号，需要把git写在&#x27;&#x27;里</span></span><br><span class="line"><span class="comment">    2.type:和repo:后边都需要加一个空格  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">type: git </span><br><span class="line">repo: https:<span class="comment">//benwang717.github.io</span></span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><hr><p>hexo d#部署到Github仓库里<br>&#x2F;*<br>到这里基本上就已经部署完成了，有几个需要注意的点：<br>1.在最初安装好git之后，Windows环境下 记得在 hexo d 之前敲<br>    git config –global user.email “xxx” 设置一个你自己的邮箱<br>    git config –global user.name “xxx”  设置你的昵称</p><p>2.在完成上述步骤之后，如果执行 hexo d 依然有错误</p><p>类似于”OpenSSL SSL_read: Connection was reset, errno 10054”这样的错误<br>可以通过 解除SSL认证 的方式尝试解决 具体的方法如下：<br>在当前文件位置下通过 Git Bash 中输入以下命令：<br>git config –global http.sslVerify “false” </p><p>更多问题可参考”<a href="https://blog.csdn.net/m0_51269961/article/details/123709195">https://blog.csdn.net/m0_51269961/article/details/123709195</a>“<br>*&#x2F;<br><a href="https://benwang717.github.io/">https://benwang717.github.io</a> #访问这个地址可以查看博客</p><p> git clone <a href="https://benwang717.github.io/">https://benwang717.github.io</a> themes&#x2F;yilia  #下载yilia主题到本地</p><p>#修改hexo根目录下的 _config.yml 文件 ： theme: yilia</p><p>hexo c#清理一下<br>hexo g#生成<br>hexo d#部署到远程Github仓库</p><p>或：</p><p>hexo c#清理一下<br>hexo d -g #部署+生成</p><p><a href="https://benwang717.github.io/">https://benwang717.github.io/</a>  #查看博客</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
